<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>百度知道</title>
    </head>
    <body><p>标题为:什么是算法?</p><p>内容为:算法是在有限步骤内求解某一问题所使用的一组定义明确的规则。通俗点说，就是计算机解题的过程。在这个过程中，无论是形成解题思路还是编写程序，都是在实施某种算法。前者是推理实现的算法，后者是操作实现的算法。 <br /><br />一个算法应该具有以下五个重要的特征： <br /><br />1、有穷性： 一个算法必须保证执行有限步之后结束； <br /><br />2、确切性： 算法的每一步骤必须有确切的定义； <br /><br />3、输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件； <br /><br />4、输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； <br /><br />5、可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。</p><br><p>标题为:算法是什么意思 谢谢</p><p>内容为:就是做一件事或处理一个问题给出的详细的步骤。<br /><br />算法的概念<br /><br /> 什么叫算法<br /><br />    算法（Algorithm）是解题的步骤，可以把算法定义成解一确定类问题的任意一种特殊的方法。在计算机科学中，算法要用计算机算法语言描述，算法代表用计算机解一类问题的精确、有效的方法。算法+数据结构=程序，求解一个给定的可计算或可解的问题，不同的人可以编写出不同的程序，来解决同一个问题，这里存在两个问题：一是与计算方法密切相关的算法问题；二是程序设计的技术问题。算法和程序之间存在密切的关系。<br />    算法是一组有穷的规则，它们规定了解决某一特定类型问题的一系列运算，是对解题方案的准确与完整的描述。制定一个算法，一般要经过设计、确认、分析、编码、测试、调试、计时等阶段。<br />    对算法的学习包括五个方面的内容：① 设计算法。算法设计工作是不可能完全自动化的，应学习了解已经被实践证明是有用的一些基本的算法设计方法，这些基本的设计方法不仅适用于计算机科学，而且适用于电气工程、运筹学等领域；② 表示算法。描述算法的方法有多种形式，例如自然语言和算法语言，各自有适用的环境和特点；③确认算法。算法确认的目的是使人们确信这一算法能够正确无误地工作，即该算法具有可计算性。正确的算法用计算机算法语言描述，构成计算机程序，计算机程序在计算机上运行，得到算法运算的结果；④ 分析算法。算法分析是对一个算法需要多少计算时间和存储空间作定量的分析。分析算法可以预测这一算法适合在什么样的环境中有效地运行，对解决同一问题的不同算法的有效性作出比较；⑤ 验证算法。用计算机语言描述的算法是否可计算、有效合理，须对程序进行测试，测试程序的工作由调试和作时空分布图组成。<br /><br />      算法的特性<br /><br />    算法的特性包括：① 确定性。算法的每一种运算必须有确定的意义，该种运算应执行何种动作应无二义性，目的明确；② 能行性。要求算法中有待实现的运算都是基本的，每种运算至少在原理上能由人用纸和笔在有限的时间内完成；③ 输入。一个算法有0个或多个输入，在算法运算开始之前给出算法所需数据的初值，这些输入取自特定的对象集合；④ 输出。作为算法运算的结果，一个算法产生一个或多个输出，输出是同输入有某种特定关系的量；⑤ 有穷性。一个算法总是在执行了有穷步的运算后终止，即该算法是可达的。<br />满足前四个特性的一组规则不能称为算法，只能称为计算过程，操作系统是计算过程的一个例子，操作系统用来管理计算机资源，控制作业的运行，没有作业运行时，计算过程并不停止，而是处于等待状态。</p><br><p>标题为:算法的五大特性是什么</p><p>内容为:此次没有获取到</p><br><p>标题为:算法的定义</p><p>内容为:算法（Algorithm）是一系列解决问题的清晰指令，也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。<br />  算法可以理解为有基本运算及规定的运算顺序所构成的完整的解题步骤。或者看成按照要求设计好的有限的确切的计算序列，并且这样的步骤和序列可以解决一类问题。</p><br><p>标题为:时间的算法</p><p>内容为:简单的说就是 秒 分 为 60进制 <br />小时为24进制 <br /><br />类似于我们经常用的10进制.. <br />逢10进一<br /><br />秒分为逢60进一...<br />所以可以很简单算出  5:55 中55加5=60进1 为6:00 6:15  15+前面5=20分钟..<br />就这样..<br /><br />看成纯数学问题就简单了...希望楼主能够明白.<br />其实就是简单时间 没有必要复杂化了</p><br><p>标题为:算法具有什么特征</p><p>内容为:一个算法应该具有以下五个重要的特征： <br />  1、有穷性： 一个算法必须保证执行有限步之后结束； <br />  2、确切性： 算法的每一步骤必须有确切的定义； <br />  3、输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件； <br />  4、输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； <br />  5、可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成</p><br><p>标题为:算法怎么学</p><p>内容为:此次没有获取到</p><br><p>标题为:什么叫算法？什么叫计算机算法？</p><p>内容为:此次没有获取到</p><br><p>标题为:提问！算法到底有什么用啊！</p><p>内容为:学了数据结构了以后，就算偶们不说你也会知道算法的重要。。。。<br /><br />咱举个非常简单的例子，编一个比较n个数的大小并排列，但是用一般法、冒泡法、折半法.....各种不一样的算法效率是不一样的。<br /><br />详情还是请仔细翻阅《数据结构》并把指针之类重要的内容全部搞清楚.....<br /><br />做学问切勿心急，欲速而不达~~~~</p><br><p>标题为:计算机的算法具有哪些特性？</p><p>内容为:计算机的算法具有的特性：<br />1.有穷性。一个算法应包含有限的操作步骤，而不能是无限的。事实上&quot;有穷性&quot;往往指&quot;在合理的范围之内&quot;。如果让计算机执行一个历时1000年才结束的算法，这虽然是有穷的，但超过了合理的限度，人们不把他视为有效算法。<br />2. 确定性。算法中的每一个步骤都应当是确定的，而不应当是含糊的、模棱两可的。算法中的每一个步骤应当不致被解释成不同的含义，而应是十分明确的。也就是说，算法的含义应当是唯一的，而不应当产生&quot;歧义性&quot;。<br />3. 有零个或多个输入、所谓输入是指在执行算法是需要从外界取得必要的信息。<br />4. 有一个或多个输出。算法的目的是为了求解，没有输出的算法是没有意义的。<br />5.有效性。 算法中的每一个 步骤都应当能有效的执行。并得到确定的结果。<br />计算机算法简介：<br />算法必须具备以下性质:<br />(1)算法首先必须是正确的，即对于任意的一组输入，包括合理的输入与不合理的输入，总能得到预期的输出。如果一个算法只是对合理的输入才能得到预期的输出，而在异常情况下却无法预料输出的结果，那么它就不是正确的。<br />(2)算法必须是由一系列具体步骤组成的，并且每一步都能够被计算机所理解和执行，而不是抽象和模糊的概念。<br />(3)每个步骤都有确定的执行顺序，即上一步在哪里;下一步是什么，都必须明确，无二义性。<br />(4)无论算法有多么复杂，都必须在有限步之后结束并终止运行;即算法的步骤必须是有限的。在任何情况下，算法都不能陷入无限循环中。<br />一个问题的解决方案可以有多种表达方式;但只有满足以上4个条件的解才能称之为算法。</p><br><p>标题为:什么是Levenberg-Marquart算法</p><p>内容为:此次没有获取到</p><br><p>标题为:算法和程序的区别是什么</p><p>内容为:算法是解决问题的步骤；程序是算法的代码实现<br />算法要依靠程序来完成功能；程序需要算法作为灵魂</p><br><p>标题为:标准体重的算法？</p><p>内容为:1、目前在我国尚没有统一的标准体重数据。较普遍采用的计算方法有两种： <br />一种是：成年：（身高（厘米）-100〕＊0．9= 标准体重（千克） <br />另一种是：男性：身高（厘米）－105= 标准体重（千克）， <br />女性：身高（厘米）－100= 标准体重（千克） <br />以上两种计算方法，基本已被广泛采用。 <br />另外，军事科学院还推出一计算中国人理想体重的方法： <br />北方人理想体重（千克）＝（身高厘米－150） x 0．6＋50，南方人理想体重（千克）＝（身高厘米－150） x 0．6＋48，这一计算方法，似乎比较适合南北地区中国人。 儿童标准体重的计算，简便的方法是： 1～6个月：出生体重（千克）十月龄＊0.6= 标准体重（千克）；7～ 12个月：出生体重（千克）十月龄 X 0．5= 标准体重（千克）；1岁以上：8十年龄x2= 标准体重（千克） <br />但是，由于人的体重与许多因素有关，不同人体之间有差异，在同一天不同的时间也会有一定的变化，加之所处地理位置（如地心引力的原因）、季节、气候、自身情况的不同，对体重也有一定影响，因而很难完全符合标准体重。也就是说，难以用一个恒定值来表示，而应当是一个数值范围，我们把这个数值范围称之为正常值，一般在标准体重+-10％以内的范围。超过这一范围，就可称之为异常体重。 实测体重超过标准体重，但超出部分＜ 20％者称为超重；实测体重超过标准体重 20％以上，并有脂肪百分率（F％）超过30％者则可诊断为肥胖病。体重超过标准体重的30 ％一50％，F％超过35％一45％者称中度肥胖病；超过标准体重50％以上，F％超过45％以上者称为重度肥胖病。<br /><br />2、BMI 法 <br /><br />体重指数 = 体重（公斤）除 身高（米）的平方 kg/m2 <br />正常体重 ： 体重指数 = 18 - 25 <br />超重 ：     体重指数 = 25 - 30 <br />轻度肥胖 ： 体重指数 &gt; 30 <br />中度肥胖 ： 体重指数 &gt; 35 <br />重度肥胖 ： 体重指数 &gt; 40</p><br><p>标题为:&quot;算法&quot;的基本特征有哪些？</p><p>内容为:一个算法应该具有以下五个重要的特征： <br />　　1、有穷性： 一个算法必须保证执行有限步之后结束； <br />　　2、确切性： 算法的每一步骤必须有确切的定义； <br />　　3、输入：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件； <br />　　4、输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的； <br />　　5、可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。</p><br><p>标题为:男女性标准体重的算法</p><p>内容为:根据以下公式你可以算一下： <br />男性:身高(cm)-105=标准体重(kg) <br /><br />女性:身高(cm)-100=标准体重(kg) <br /><br />以上两种计算方法，基本已被广泛采用。 <br /><br />另外，最近军事科学院还推出一计算中国人理想体重的方法： <br /><br />北方人理想体重=(身高cm-150)×0.6+50(kg) <br /><br />南方人理想体重=(身高cm-150)×0.6+48(kg) <br /><br />这一计算方法，似乎比较适合南北地区中国人。 <br /><br />儿童标准体重的计算，简便的方法是： <br /><br />1～6个月：出生体重(kg)+月龄×0.6=标准体重(kg) <br /><br />7～12个月：出生体重(kg)+月龄×0.5=标准体重(kg) <br /><br />1岁以上：8+年龄×2=标准体重(kg) <br /><br />但是，由于人的体重与许多因素有关，不同人体之间有差异，一天不同的时间内也会有一定变化，加之所处地理位置(如地心引力的原因)、季节、气候、自身情况的不同，对体重也有一定影响，因而很难完全符合标准体重。也就是说，难以用一个恒定值来表示，而应当是一个数值范围，我们把这个数值范围称之为正常值，一般在标准体重±10%以内的范围。超过这一范围，就可称之为异常体重。</p><br><p>标题为:什么是算法？算法的概念？算法的特点都有哪些？</p><p>内容为:1、算法概念：在数学上，现代意义上的“算法”通常是指可以用计算机来解决的某一类问题是程序或步骤，这些程序或步骤必须是明确和有效的，而且能够在有限步之内完成.2. 算法的特点:(1)有限性：一个算法的步骤序列是有限的，必须在有限操作之后停止，不能是无限的.(2)确定性：算法中的每一步应该是确定的并且能有效地执行且得到确定的结果，而不应当是模棱两可.(3)顺序性与正确性：算法从初始步骤开始，分为若干明确的步骤，每一个步骤只能有一个确定的后继步骤，前一步是后一步的前提，只有执行完前一步才能进行下一步，并且每一步都准确无误，才能完成问题.(4)不唯一性：求解某一个问题的解法不一定是唯一的，对于一个问题可以有不同的算法.(5)普遍性：很多具体的问题，都可以设计合理的算法去解决，如心算、计算器计算都要经过有限、事先设计好的步骤加以解决.</p><br><p>标题为:算法中&quot;&#92;&quot;与&quot;&#47;&quot;的意思分别是什么?</p><p>内容为:&quot;/&quot;是除号，是普通除法计算。&quot;&#92;&quot;是整数除法计算后的整数部分，相当于小学整数除法计算的商那部分，&quot;MOD&quot;就是余数部分。举例说明：9&#92;5=1（商1），9 mod 5=4（余4）。当对小数进行计算时，会先将小数四舍六入为整数后再行计算，当只有一位小数5时，则按单入双舍的原则舍入。如：9.5&#92;5=2，14.5&#92;5=2，9是单入，9.5入后按10计算，14是双舍，14.5舍后为14。多位小时则按4舍5入的原则处理为整数再行计算。</p><br><p>标题为:关于打折具体是怎么个算法</p><p>内容为:比如9折，就是原价的百分之九十！！自己算，以此类推</p><br><p>标题为:数据结构有哪些基本算法</p><p>内容为:此次没有获取到</p><br><p>标题为:比较算法优缺点：</p><p>内容为:作业调度算法 .<br />1.先来先服务（FCFS, First Come First Serve）是最简单的调度算法，按先后顺序进行调度。 <br /><br />定义：<br />　　按照作业提交或进程变为就绪状态的先后次序，分派CPU； <br /><br />　　当前作业或进程占用CPU，直到执行完或阻塞，才出让CPU（非抢占方式）。 <br /><br />　　在作业或进程唤醒后（如I/O完成），并不立即恢复执行，通常等到当前作业或进程出让CPU。 <br /><br />适用场景：<br />　　比较有利于长作业，而不利于短作业。因为长作业会长时间占据处理机。<br /><br />　　有利于CPU繁忙的作业，而不利于I/O繁忙的作业。 <br /><br />算法实现原理图：<br /><br />2. 轮转法(Round Robin)<br />　　轮转法是让每个进程在就绪队列中的等待时间与享受服务的时间成正比例。 <br /><br />定义：<br />　　将系统中所有的就绪进程按照FCFS原则，排成一个队列。 <br /><br />　　每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。 <br /><br />　　在一个时间片结束时，发生时钟中断。 <br /><br />　　调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。 <br /><br />　　进程可以未使用完一个时间片，就出让CPU（如阻塞）。 <br /><br />时间片长度的确定：<br />　　时间片长度变化的影响 <br /><br />　　过长－&gt;退化为FCFS算法，进程在一个时间片内都执行完，响应时间长。 <br /><br />　　过短－&gt;用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长。 <br /><br />　　对响应时间的要求：T(响应时间)=N(进程数目)*q(时间片) <br /><br />　　就绪进程的数目：数目越多，时间片越小 <br /><br />　　系统的处理能力：应当使用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。 <br /><br />算法实现原理图：<br /><br />3. 多级反馈队列算法(Round Robin with Multiple Feedback)<br />　　多级反馈队列算法是轮转算法和优先级算法的综合和发展。 <br /><br />定义：<br />　　设置多个就绪队列，分别赋予不同的优先级，如逐级降低，队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长，如逐级加倍。 <br /><br />　　新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。 <br /><br />　　仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。 <br /><br />优点：<br />　　为提高系统吞吐量和缩短平均周转时间而照顾短进程。 <br /><br />　　为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程。 <br /><br />　　不必估计进程的执行时间，动态调节 <br /><br />几点说明：<br />　　I/O型进程：让其进入最高优先级队列，以及时响应I/O交互。通常执行一个小时间片，要求可处理完一次I/O请求的数据，然后转入到阻塞队列。 <br /><br />　　计算型进程：每次都执行完时间片，进入更低级队列。最终采用最大时间片来执行，减少调度次数。 <br /><br />　　I/O次数不多，而主要是CPU处理的进程。在I/O完成后，放回优先I/O请求时离开的队列，以免每次都回到最高优先级队列后再逐次下降。 <br /><br />　　为适应一个进程在不同时间段的运行特点，I/O完成时，提高优先级；时间片用完时，降低优先级。<br /><br />算法实现原理图：<br /><br />4. 优先级法（Priority Scheduling）<br />　　优先级算法是多级队列算法的改进，平衡各进程对响应时间的要求。适用于作业调度和进程调度，可分成抢先式和非抢先式。 <br /><br />静态优先级：<br />　　作业调度中的静态优先级大多按以下原则确定： <br /><br />　　由用户自己根据作业的紧急程度输入一个适当的优先级。 <br /><br />　　由系统或操作员根据作业类型指定优先级。 <br /><br />　　系统根据作业要求资源情况确定优先级。 <br /><br />　　进程的静态优先级的确定原则： <br /><br />　　按进程的类型给予不同的优先级。 <br /><br />　　将作业的情态优先级作为它所属进程的优先级。 <br /><br />动态优先级：<br />　　进程的动态优先级一般根据以下原则确定： <br /><br />　　根据进程占用有CPU时间的长短来决定。 <br /><br />　　根据就绪进程等待CPU的时间长短来决定。 <br /><br />5．短作业优先法（SJF, Shortest Job First）<br />　　短作业优先又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。 <br /><br />定义：<br />　　对预计执行时间短的作业（进程）优先分派处理机。通常后来的短作业不抢先正在执行的作业。 <br /><br />SJF的特点：<br />　　(1) 优点： <br /><br />　　比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间； <br /><br />　　提高系统的吞吐量； <br /><br />　　(2) 缺点： <br /><br />　　对长作业非常不利，可能长时间得不到执行； <br /><br />　　未能依据作业的紧迫程度来划分执行的优先级； <br /><br />　　难以准确估计作业（进程）的执行时间，从而影响调度性能。 <br /><br />SJF的变型：<br />　　“最短剩余时间优先”SRT(Shortest Remaining Time)（允许比当前进程剩余时间更短的进程来抢占） <br /><br />　　“最高响应比优先”HRRN(Highest Response Ratio Next)（响应比R = (等待时间 + 要求执行时间) / 要求执行时间，是FCFS和SJF的折衷） <br /><br />6. 最高响应比优先法(HRN，Highest Response_ratio Next)<br />　　最高响应比优先法是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。 <br /><br />　　响应比R定义如下： R =(W+T)/T = 1+W/T <br /><br />　　其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRN方式时其吞吐量将小于采用SJF 法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p><br><p>标题为:c语言算法中的五个特性是什么？</p><p>内容为:此次没有获取到</p><br><p>标题为:算法优劣的五个标准是什么</p><p>内容为:时间复杂度：是某个算法的时间耗费，它是该算法所求解问题规模n的函数。 <br />渐近时间复杂度：是指当问题规模趋向无穷大时，该算法时间复杂度的数量级。 <br />评价一个算法的时间性能时，主要标准就是算法的渐近时间复杂度。 <br />算法中语句的频度不仅与问题规模有关，还与输入实例中各元素的取值相关。 <br />时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n^2)、立方阶O(n^3)、……k次方阶O(n^k)、指数阶O(2^n)。 <br />空间复杂度：是某个算法的空间耗费，它是该算法所求解问题规模n的函数。 <br />算法的时间复杂度和空间复杂度合称算法复杂度。</p><br><p>标题为:手指算法是怎么算的</p><p>内容为:手指速算法也叫手心算，是一种不用算盘进行数学运算的方法。长期以来,人们进行计算,总是要通过笔算或借助于其它计算器(如算盘,计算机等),其实,我们每一个正常人的手也是一个完美的计算器,用手心算可以进行多位数的加、减、乘、除、平方、开方等六种运算,其运算速度(当然要经过一定时间的练习),加减可与电子计算机相媲美,乘除比珠算要快,平方、开平方比笔算快得多。<br />手指速算法-----手心算------ 表示数的方法是以左手五指设点作为数码盘，每个手指表示一位数，五个手指可表示个、十、百、千、万五位数字。<br />每个手指上9个数，首先我们看，我们的手指上有三根骨节，从上到下，第一骨节中部左侧表示1，第二骨节中部左侧表示2，第三骨节中部左侧表示3，从3往下移到手掌上表示4，手指的上端表示5，指肚表示6，手掌上有三道横纹，从上到下，第一道横纹表示7，第二道横纹表示8，第三道横纹表示9。<br />手指速算法。手心算的计算方法是采用心算办法利用大脑形象再现指算计算过程而求出结果的方法。它把左手当作一架五档的小算盘，用右手五指点按这个小算盘来进行计算。记数时要用右手的手指点左手相对应的手指。其明确分工是：右手拇指/专点左手拇指，右手食指专点左手食指，右手中指专点左手中指，右手无名指专点左手无名指，右手小指专点左手小指。对应专业分工各不相扰。哪个手指点按数，哪个手指就伸开，手指不点按数时弯屈，表示0。它不借助于任何计算工具，不列运算程序，只需两手轻轻一合，便知答数，便可进行十万以内任意数的加减乘除四则运算。<br />手指速算法，　手心算----减少笔算列算式复杂的运算过程，省时省力，提高学生计算速度。</p><br><p>标题为:算法 o（1）什么意思</p><p>内容为:这是常数阶时间复杂度。<br />一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(f(n))<br />按数量级递增排列，常见的时间复杂度有：<br />常数阶O(1),对数阶O(log2n),线性阶O(n),<br />线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),...，<br />k次方阶O(n^k),指数阶O(2^n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><br><p>标题为:模型与算法之间是什么关系？？</p><p>内容为:模型是一类问题的解题步骤，亦即一类问题的算法。如果问题的算法不具有一般性，就没有必要为算法建立模型，因为此时个体和整体的对立不明显，模型的抽象性质也体现不出来。<br /><br />数学模型还没有一个统一的准确的定义，因为站在不同的角度可以有不同的定义。不过我们可以给出如下定义。&quot;数学模型是关于部分现实世界和为一种特殊目的而作的一个抽象的、简化的结构。&quot;具体来说，数学模型就是为了某种目的，用字母、数字及其它数学符号建立起来的等式或不等式以及图表、图象、框图等描述客观事物的特征及其内在联系的数学结构表达式。<br /><br />算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><br><p>标题为:实现算法：</p><p>内容为:此次没有获取到</p><br><p>标题为:【比较难写的算法】最坏情况线性时间的选择</p><p>内容为:实际上比平均情况下线性时间的选择要复杂很多（算法导论上伪代码都没有）<br />问题是快速排序要求枢纽元在最后一个，如果采用hoare的划分算法，就没有这个要求。而给出的是枢纽元的值，然后要找到位置（搜索一遍），再交换。<br />如果采用hoare划分法，不用搜索，不过算法和书上描述的就稍有不同了。<br /><br />另外，因为代码复杂，所以对于随机输入，此算法较慢<br />下面是hoare划分的选择代码<br /><br /># include &lt;ctime&gt;<br /># include &lt;cstdlib&gt;<br /># include &lt;iostream&gt;<br /><br />inline void swap(int &x, int&y)<br />{<br />    int temp = x;<br />    x = y;<br />    y = temp;<br />}<br /><br />// A[p..r]<br />int hoarePartitionX(int *A, int p, int r, int x)<br />{<br />    int i = p - 1;<br />    int j = r + 1;<br /><br />    for(;;)<br />    {<br />        while( A[--j] &gt; x)<br />            ;<br />        while( A[++i] &lt; x)<br />            ;<br />        if(i&lt;j)<br />        {<br />            swap(A[i], A[j]);<br />        }<br />        else<br />        {<br />            return j;<br />        }<br />    }<br />}<br /><br />// A[0..size-1]<br />void insertionSort(int *A, int size)<br />{<br /> int i;<br /> int key;<br /><br /> for(int j=1; j&lt;size; j+=1)<br /> {<br />  key = A[j];<br />  i = j - 1;<br />  while(i &gt;= 0 && A[i] &gt; key)<br />  {<br />   A[i+1] = A[i];<br />   i -= 1;<br />  }<br />  A[i+1] = key;<br /> }<br />}<br /><br />// return the ith smallest element of A[p..r]<br />int select(int *A, int p, int r, int i)<br />{<br /><br />    if(p == r) // only one element, just return<br />    {<br />        return A[p];<br />    }<br /><br />    // #1. groupNum & rest<br /> int groupNum = (r - p + 1) / 5; // not counting the rest<br /> int rest = (r - p + 1) % 5;<br /><br /> // #2. sort the groups<br /><br />    for(int t=0; t&lt;groupNum; t+=1)<br />    {<br />        insertionSort(A + p + t*5, 5);<br />    }<br /><br />    if(rest != 0)<br />    {<br />  insertionSort(A + p + groupNum * 5, rest);<br />    }<br /><br /> // #3. get the mid value x<br /> int *mids;<br /> if(rest == 0)<br />        mids = new int[groupNum];<br />    else<br />        mids = new int[groupNum+1];<br /><br /> for(int t=0; t&lt;groupNum; t+=1)<br /> {<br />        mids[t] = A[ p + t*5 + 2 ];<br /> }<br /> if(rest != 0)<br /> {<br />  mids[groupNum] = A[ p + groupNum*5 + (rest-1)/2 ];<br /> }<br /><br />    int x;<br /> if( rest == 0 )<br /> {<br />  x = select(mids, 0, groupNum-1, (groupNum-1) / 2 + 1);<br /> }<br /> else<br /> {<br />  x = select(mids, 0, groupNum, groupNum / 2 + 1);<br /> }<br /><br />    delete []mids;<br /><br /> // #4. partition with x<br /> int k = hoarePartitionX(A, p, r, x) - p + 1; // so the value A[p+k-1] is the kth smallest<br /><br /> // #5.<br /> if(i &lt;= k)<br /> {<br />        return select(A, p, p+k-1, i);<br /> }<br /> else<br /> {<br />        return select(A, p+k, r, i-k);<br /> }<br />}<br /><br />int main()<br />{<br />    int array[100];<br />    for(int i=0; i&lt;100; i+=1)<br />        array[i] = i;<br /><br />    for(int i=0; i&lt;100; i+=1)<br />    {<br />        int rnd = rand()%100;<br />        swap(array[0], array[rnd]);<br />    }<br /><br />    std::cout &lt;&lt; select(array, 0, 99, 82);<br /><br /> std::cin.get();<br />    return 0;<br />}</p><br><p>标题为:哪些常见算法属于贪婪算法？</p><p>内容为:显然KMP和FLOYD算法不是贪心算法，FLOYD算法是使用了类似于动态规划的思想，而KMP算法则是对串的前缀进行去处理得到所有可能出现匹配的位置从而减少不必要的位移。贪心算法可能还有很多，但是一般能用到的可能只有这些。在确定一个问题是否能用贪心来解决的时候应该线能够证明在这里使用贪心算法的正确性（详见算法导论）</p><br><p>标题为:14减9等于5的三种算法是怎样的?</p><p>内容为:14-9=5+9-9=5<br />14-9=14-（10-1）=14-10+1=4+1=5<br />14-9=4+10-9=4+（10-9）=4+1=5</p><br><p>标题为:UnpackNormal算法是什么意思</p><p>内容为:此次没有获取到</p><br><p>标题为:什么是dp算法？</p><p>内容为:DP算法是解决多阶段决策过程最优化问题的一种常用方法。<br />多阶段决策过程（multistep decision process）是指这样一类特殊的活动过程，过程可以按时间顺序分解成若干个相互联系的阶段，在每一个阶段都需要做出决策，全部过程的决策是一个决策序列。动态规划（dynamic programming）算法是解决多阶段决策过程最优化问题的一种常用方法，难度比较大，技巧性也很强。利用动态规划算法，可以优雅而高效地解决很多贪婪算法或分治算法不能解决的问题。<br />动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果，与贪婪算法不同的是，在贪婪算法中，每采用一次贪婪准则，便做出一个不可撤回的决策；而在动态规划算法中，还要考察每个最优决策序列中是否包含一个最优决策子序列，即问题是否具有最优子结构性质。</p><br><p>标题为:算法和数据结构有什么区别？？</p><p>内容为:其实两者可以说关联不大。<br />算法就是一个处理的方法，比如大学里基础的排序算法，就是为了完成对一组数据排序。查找算法，就是为了在一个集合中查找需要的项。除此之外，还有很多算法，比方说，加密、压缩、图像处理。<br />而数据结构就是数据的结构。比方说队列、堆、栈、链表、树等。<br />大学里的《算法与数据结构》这门课是个入门的算法课和数据结构课程。教授针对不同的数据结构进行的排序、查找、遍历的不同算法。仅是算法基础，就像大学里都是以C语言作为入门语言一样的。</p><br><p>标题为:一平方米的算法是怎样算的？</p><p>内容为:780cm*175cm<br />=7.8m*1.75m<br />=13.65㎡<br />160*13.65=2184元。</p><br><p>标题为:下列关于算法的说法中，正确的是（　　）A．算法是某个问题的解决过程B．算法可以无限不停地操作下去C．</p><p>内容为:此次没有获取到</p><br><p>标题为:十二时辰算法</p><p>内容为:子时:又称“夜半”时间是前日夜11时～当日凌晨1时（北京时间，24小时制，下同）<br />丑时：又称“鸡鸣”时间是深夜过后的1～3时<br />寅时：又称“平旦”时间是每天清晨的3～5时<br />卯时：又称“日出”时间是每天清早的5~7时<br />辰时：又称“食时”时间是每天的7～9时<br />巳时:又称“隅中”【yú zhōng】时间是上午的9～11时<br />午时 :又称“日中” 时间是每天的11～13时<br />未时:又称“日昳”【rì dié】时间是每日的13～15时<br />申时:又称“晡时” 【bū shí】  时间是每天的15～17时<br />酉时:又称“日入” 时间是每日的17～19时<br />戌时又称“黄昏”时间是19～21时<br />亥时又称“人定”时间是当夜的21～23时<br />望采纳</p><br><p>标题为:立方米的算法</p><p>内容为:此次没有获取到</p><br><p>标题为:算法的是指什么</p><p>内容为:是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量</p><br><p>标题为:罩杯的算法</p><p>内容为:AA、A、B、C、D、E、F是指罩杯大小，胸围减去下胸围就是罩杯大小，如果你胸围减下胸围之差是10cm那么你应用A罩。 <br />罩杯尺寸胸围与下胸围之差 <br /><br />AA 7.5cm <br />A 10cm <br />B 12.5cm <br />C 15cm <br />D 17.5cm <br />E 20cm <br />F 22.5cm <br /><br />例：你的胸围量得为92cm，你的下胸围量得为80cm，两数相减得12cm，那就用B杯，您应该戴的胸罩为80B的。</p><br><p>标题为:算法的五个特征是？</p><p>内容为:此次没有获取到</p><br><p>标题为:大家能给穷举一下自动控制领域有哪些控制算法吗？</p><p>内容为:还有非线性控制，自适应控制，模型预测控制，数字控制，智能控制（神经网络，贝叶斯模型，模糊算法，机器学习，进化，遗传等等）。这些分类之间都有交集。<br /><br />算法只是理论而已，和复杂的实际情况还不是一回事。</p><br><p>标题为:C语言的算法描述是什么?</p><p>内容为:1、算法描述就是用伪代码或其他文字来叙述编程思想，包含内部逻辑，数据流处理等。<br />2、算法（Algorithm）是指完成一个任务所需要的具体步骤和方法。也就是说给定初始状态或输入数据，能够得出所要求或期望的终止状态或输出数据。算法常常含有重复的步骤和一些比较或逻辑判断。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><br><p>标题为:详细的算法，谢谢</p><p>内容为:（302.4+X）-4447.46=277.66<br />解：302.4+X=277.66+4447.46<br />302.4+X=4725.12<br />X=4725.12-302.4<br />X=4422.72</p><br><p>标题为:什么是AI算法</p><p>内容为:AI 人工智能<br /><br />用程序实现搜寻答案的计算方法<br /><br />比如说一棵二叉树上的某一点的数据是你要的<br />你就要写一个程序让它找到这个数据<br />而这个程序怎么找 就要看算法了~<br /><br />常见的算法大概有什么A*算法之类的</p><br><p>标题为:C语言，闰年算法</p><p>内容为:判断闰年的方法是该年能被4整除并且不能被100整除，或者是可以被400整除。<br />main()<br />{int n;<br />printf(&quot;请输入年份&quot;); <br />scanf(&quot;%d&quot;,&n); <br />if(((n%4)==0)&&(n%100)!=0)||(n%400==0))<br />printf(&quot;闰年&quot;); <br />else <br />printf(&quot;不是闰年&quot;);<br />}</p><br><p>标题为:社保怎么个算法？</p><p>内容为:以上,这么算下来,单位每个月为你缴纳的社保比例应该是21%+9%+2%+0.5%+0.8%+8%=41.3%<br />你自己每个月为你缴纳的社保比例应该是8%+2%+10块+1%+8%=19%+10块<br />暂时去掉你交的10块钱不谈,单位缴纳的比例和你缴纳的比例应该为413:190,这就是说如果你每个月为自己的社保缴纳了190块钱,那么单位会往你的社保帐户上打进去413块钱,每个月你的社保帐户上增加的钱就应该是413+190=603块钱,举个例子说明:比如你月工资为1000,那么企业为职工缴纳社保的钱为1000×41.3%=413元,而职工自己每个月要交1000×19%+10=200元,这样你和单位每个月应该交的社保费就出来了。</p><br><p>标题为:硬盘容量算法</p><p>内容为:电脑的算法是1024的。。也就是说 1024KB=1MB  1024MB=1GB 1024GB=1TB<br /> <br />但是硬盘存储的算法是 1000KB=1MB  所以厂家说自己的是1GB的存储实际只有940MB左右<br /> <br /> 也就是说97TB的硬盘显示86TB是对的。实际存储也是86TB</p><br><p>标题为:算法与程序的关系</p><p>内容为:此次没有获取到</p><br><p>标题为:什么是RAS算法？</p><p>内容为:1978年就出现了这种算法，它是第一个既能用于数据加密 也能用于数字签名的算法。它易于理解和操作，也很流行。算 法的名字以发明者的名字命名：Ron Rivest, AdiShamir 和 Leonard Adleman。但RSA的安全性一直未能得到理论上的证明。 <br /><br />    RSA的安全性依赖于大数分解。公钥和私钥都是两个大素数 （大于 100个十进制位）的函数。据猜测，从一个密钥和密文 推断出明文的难度等同于分解两个大素数的积。  <br /><br /> 密钥对的产生:选择两个大素数，p 和q 。计算：n = p * q <br />然后随机选择加密密钥e，要求 e 和 ( p - 1 ) * ( q - 1 ) <br />互质.<br />最后，利用Euclid 算法计算解密密钥d, 满足  <br />e * d = 1 ( mod ( p - 1 ) * ( q - 1 ) ) <br />其中n和d也要互质。数e和 n是公钥，d是私钥。<br />两个素数p和q不再需要，应该丢弃，不要让任何人知道。 <br />加密信息 m（二进制表示）时，首先把m分成等长数据 块 m1 ,m2,..., mi ，块长s，其中 2^s &lt;= n, s 尽可能的大。<br />对 应的密文是： <br />ci = mi^e ( mod n ) ( a ) <br />解密时作如下计算： <br />mi = ci^d ( mod n ) ( b ) <br />RSA 可用于数字签名，方案是用 ( a ) 式签名， ( b ) 式验证。<br />具体操作时考虑到安全性和 m信息量较大等因素，一般是先作HASH 运算。 <br /><br />RSA 的安全性。 <br />RSA的安全性依赖于大数分解，但是否等同于大数分解一直未能得到理 <br />论上的证明，因为没有证明破解RSA就一定需要作大数分解。假设存在 <br />一种无须分解大数的算法，那它肯定可以修改成为大数分解算法。目前， RSA的一些变种算法已被证明等价于大数分解。不管怎样，分解n是最显 然的攻击方法。现在，人们已能分解140多个十进制位的大素数。因此， 模数n必须选大一些，因具体适用情况而定。 <br /><br />RSA的速度: <br />由于进行的都是大数计算，使得RSA最快的情况也比DES慢上100倍，无论是软件还是硬件实现。速度一直是RSA的缺陷。一般来说只用于少量据加密。 <br /><br />RSA的选择密文攻击: <br />RSA在选择密文攻击面前很脆弱。一般攻击者是将某一信息作一下伪装 <br />(Blind)，让拥有私钥的实体签署。然后，经过计算就可得到它所想要的信息。实际上，攻击利用的都是同一个弱点，即存在这样一个事实：乘幂保 留了输入的乘法结构： <br />( XM )^d = X^d *M^d mod n <br />前面已经提到，这个固有的问题来自于公钥密码系统的最有用的特征 --每个人都能使用公钥。但从算法上无法解决这一问题，主要措施有两条：一条是采用好的公钥协议，保证工作过程中实体不对其他实体 <br />任意产生的信息解密，不对自己一无所知的信息签名；另一条是决不 <br />对陌生人送来的随机文档签名，签名时首先使用One-Way HashFunction <br />对文档作HASH处理，或同时使用不同的签名算法。在中提到了几种不 <br />同类型的攻击方法。    <br />RSA的公共模数攻击。 <br />若系统中共有一个模数，只是不同的人拥有不同的e和d，系统将是危险 <br />的。最普遍的情况是同一信息用不同的公钥加密，这些公钥共模而且互 <br />质，那末该信息无需私钥就可得到恢复。设P为信息明文，两个加密密钥 <br />为e1和e2，公共模数是n，则： <br />C1 = P^e1 mod n <br />C2 = P^e2 mod n <br />密码分析者知道n、e1、e2、C1和C2，就能得到P。 <br />因为e1和e2互质，故用Euclidean算法能找到r和s，满足： <br />r * e1 + s * e2 = 1 <br />假设r为负数，需再用Euclidean算法计算C1^(-1)，则 <br />( C1^(-1) )^(-r) * C2^s = P mod n <br /><br />另外，还有其它几种利用公共模数攻击的方法。总之，如果知道给定模数的一对e和d，一是有利于攻击者分解模数，一是有利于攻击者计算出其它成对的e’和d’，而无需分解模数。解决办法只有一个，那就是不要共享模数n。 <br />RSA的小指数攻击。 有一种提高RSA速度的建议是使公钥e取较小的值，这样会使加密变得易于实现，速度有所提高。但这样作是不安全的，对付办法就是e和d都取较大的值。 <br />RSA算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现在已近二十年，经历了各 种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。 <br />RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难 度与大数分解难度等价。即RSA的重大缺陷是无法从理论上把握它的保密性 能如何，而且密码学界多数人士倾向于因子分解不是NPC问题。 <br /><br />RSA的缺点主要有： <br />A)产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次 一密。<br />B)分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级； <br />且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。 <br />目前，SET(Secure Electronic Transaction)协议中要求CA采用2048比特长的密钥，其他实体使用1024比特的密钥。</p><br><p>标题为:增值税点的正确的算法怎么算？</p><p>内容为:此次没有获取到</p><br><p>标题为:WAP算法该选什么?</p><p>内容为:　　WAP算法简介：<br />　　WAP算法其实叫PSK（pre-shared key），长度一般是8-63字节，它加上ssid通过一定的算法可以得到PMK（pairwise master key）。PMK=SHA-1(ssid,psk) ，PMK的长度是定长的，都是64字节。由于计算PMK的过程开销比较大，是我们破解花费时间长的键，所以采用以空间换时间的原则把PMK事先生成好，这个事先生成好的表就是常说的HASH表（生成PMK的算法是一种哈希），这个工作就是用airlib-ng这个工具来完成的。<br />　　WAP算法选择方法：<br />　　一、选择TKIP：<br />　　TKIP是包裹在已有WEP密码外围的一层“外壳”。TKIP由WEP使用的同样的加密引擎和RC4算法组成。不过，TKIP中密码使用的密钥长度为128位。这解决了WEP的第一个问题：过短的密钥长度。<br />　　二、选择AES：<br />　　AES对称密码体制的发展趋势将以分组密码为重点。分组密码算法通常由密钥扩展算法和加密（解密）算法两部分组成。密钥扩展算法将b字节用户主密钥扩展成r个子密钥。加密算法由一个密码学上的弱函数f与r个子密钥迭代r次组成。混乱和密钥扩散是分组密码算法设计的基本原则。抵御已知明文的差分和线性攻击，可变长密钥和分组是该体制的设计要点。</p><br><p>标题为:用电量的算法</p><p>内容为:电器用电量的计算方法：<br />电器的功率用“瓦”来表示，1千瓦小时=1度电。在每件电器的后面都有一个“铭牌”上面标用550W（瓦）或350W（瓦）等数字来表示它每小时所需要耗用的电能 。<br /><br />比如一件电器是500W（瓦），这表示它一小时是0。5度电。那它24小时用电量就是12度电。<br /><br />简单点，<br />瓦数是500，就用0。5*24小时=12度电，<br />是550就用0。55*24小时=13。2度电，依此类推。</p><br><p>标题为:成本算法是什么</p><p>内容为:1．加权移动平均<br />核算成本单价=（不含税库存金额+不含税入库金额）/（库存数量+入库数量）<br />2．先进先出<br />按进货时的单价及数量记录序列，以日期升序提取进价作为销售出库成本单价，核算出库成本金额。<br />3．后进先出<br />按进货时的单价及数量记录序列，以日期降序提取进价作为销售出库成本单价，核算出库成本金额。<br />   4．高进先出<br />按进货时的单价及数量记录序列，以单价降序提取进价作为销售出库成本单价，核算出库成本金额。<br />   5．低进先出<br />按进货时的单价及数量记录序列，以单价升序提取进价作为销售出库成本单价，核算出库成本金额。<br />6．最高进价<br />在进货时比较刷新最高进价记录，以此进价作为销售出库成本单价，核算出库成本金额。<br />7．最低进价<br />在进货时比较刷新最低进价记录，以此进价作为销售出库成本单价，核算出库成本金额。<br />  8．最后进价<br />在进货时刷新最后进价记录，以此进价作为销售出库成本单价，核算出库成本金额。<br />  9．个别计价<br />此核算方法与商品的批次号结合使用。在进货时记录商品各批次的进价，以此作为销售出库商品不同批次的成本单价。<br />  10．固定成本<br />制定商品的成本单价，作为销售成本单价核算商品出库成本金额。<br />  11．综合毛利率<br />通过定义预期毛利率，在销售时根据销售单价计算出库成本单价。<br />出库成本金额=不含税销售额*（1-毛利率）<br /><br />平衡公式：<br />采购金额=库存金额+出库成本<br />销售金额=出库成本+毛利<br />本期结存=<br />上期结转+本期采购+本期外调入+内部调入+本期盘盈<br />-本期销售-本期外调出-内部调出-本期盘亏<br /><br />其他公式：<br />数量=包装数量*计量规格+零散数量<br />金额=单价*数量*扣率<br />税额=金额*税率<br />含税金额=（1+税率%）*金额<br />零售金额=零售价*数量<br />帐格式：单据编号、日期、上期结存、进项、出项、结存、其它附属信息<br />商品总帐：对商品的总库存（所有库房数值求和及业务集合）进行核算。<br />货位商品帐：对商品在某库房的库存进行核算。<br />单位往来帐：对某单位的应收应付及实收实付款项进行登记。<br />财务帐簿：各类业务在会计科目中的登记。</p><br><p>标题为:如何衡量一个时间算法的时间效率</p><p>内容为:时间复杂度<br /> <br />（1）时间频度 <br /><br />　　一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。算法的时间复杂度是指执行算法所需要的计算工作量。 <br /><br />　　（2）时间复杂度<br />　　在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 <br /><br />　　一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 <br /><br />　　在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n^2+3n+4与T(n)=4n^2+2n+1它们的频度不同，但时间复杂度相同，都为O(n^2)。 <br /><br />　　按数量级递增排列，常见的时间复杂度有： <br /><br />　　常数阶O(1),对数阶O(log2n)(以2为底n的对数，下同),线性阶O(n), <br /><br />　　线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),...， <br /><br />　　k次方阶O(n^k),指数阶O(2^n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 <br /><br />　　算法的时间性能分析 <br /><br />　　（1）算法耗费的时间和语句频度 <br /><br />　　一个算法所耗费的时间=算法中每条语句的执行时间之和 <br /><br />　　每条语句的执行时间=语句的执行次数(即频度(Frequency Count))×语句执行一次所需时间 <br /><br />　　算法转换为程序后，每条语句执行一次所需的时间取决于机器的指令性能、速度以及编译所产生的代码质量等难以确定的因素。 <br /><br />　　若要独立于机器的软、硬件系统来分析算法的时间耗费，则设每条语句执行一次所需的时间均是单位时间，一个算法的时间耗费就是该算法中所有语句的频度之和。<br />　　求两个n阶方阵的乘积 C=A×B,其算法如下: <br /><br />　　# define n 100 // n 可根据需要定义,这里假定为100 <br /><br />　　void MatrixMultiply(int A[a]，int B [n][n]，int C[n][n]) <br /><br />　　{ //右边列为各语句的频度 <br /><br />　　int i ,j ,k; <br /><br />　　(1) for(i=0; i&lt;n;j++) n+1 <br /><br />　　(2) for (j=0;j&lt;n;j++) { n(n+1) <br /><br />　　(3) C[i][j]=0; n <br /><br />　　(4) for (k=0; k&lt;n; k++) nn(n+1) <br /><br />　　(5) C[i][j]=C[i][j]+A[i][k]*B[k][j];n <br /><br />　　} <br /><br />　　} <br /><br />　　该算法中所有语句的频度之和(即算法的时间耗费)为： <br /><br />　　T(n)=nn(n+1) (1.1) <br /><br />　　分析： <br /><br />　　语句(1)的循环控制变量i要增加到n，测试到i=n成立才会终止。故它的频度是n+1。但是它的循环体却只能执行n次。语句(2)作为语句(1)循环体内的语句应该执行n次，但语句(2)本身要执行n+1次，所以语句(2)的频度是n(n+1)。同理可得语句(3)，(4)和(5)的频度分别是n，nn(n+1)和n。 <br /><br />　　算法MatrixMultiply的时间耗费T(n)是矩阵阶数n3的函数。 <br /><br />　　（2）问题规模和算法的时间复杂度<br />　　算法求解问题的输入量称为问题的规模(Size),一般用一个整数表示。 <br /><br />　　矩阵乘积问题的规模是矩阵的阶数。 <br /><br />　　一个图论问题的规模则是图中的顶点数或边数。 <br /><br />　　一个算法的时间复杂度(Time Complexity, 也称时间复杂性)T(n)是该算法的时间耗费，是该算法所求解问题规模n的函数。当问题的规模n趋向无穷大时，时间复杂度T(n)的数量级(阶)称为算法的渐进时间复杂度。 <br /><br />　　算法MatrixMultidy的时间复杂度T(n)如(1.1)式所示，当n趋向无穷大时，显然有T(n)~O(n3); <br /><br />　　这表明，当n充分大时，T(n)和n3之比是一个不等于零的常数。即T(n)和n3是同阶的，或者说T(n)和n3的数量级相同。记作T(n)=O(n3)是算法MatrixMultiply的渐近时间复杂度。 <br /><br />　　（3）渐进时间复杂度评价算法时间性能 <br /><br />　　主要用算法时间复杂度的数量级(即算法的渐近时间复杂度)评价一个算法的时间性能。<br />　　算法MatrixMultiply的时间复杂度一般为T(n)=O(n3)，f(n)=n3是该算法中语句(5)的频度。下面再举例说明如何求算法的时间复杂度。 <br /><br />　　交换i和j的内容。 <br /><br />　　Temp=i; <br /><br />　　i=j; <br /><br />　　j=temp; <br /><br />　　以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。　　<br />注意：如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。<br />　　变量计数之一：<br />　　(1) x=0;y=0; <br /><br />　　(2) for(k-1;k&lt;=n;k++) <br /><br />　　(3) x++; <br /><br />　　(4) for(i=1;i&lt;=n;i++) <br /><br />　　(5) for(j=1;j&lt;=n;j++) <br /><br />　　(6) y++; <br /><br />　　一般情况下，对步进循环语句只需考虑循环体中语句的执行次数，忽略该语句中步长加1、终值判别、控制转移等成分。因此，以上程序段中频度最大的语句是(6)，其频度为f(n)=n2，所以该程序段的时间复杂度为T(n)=O(n2)。 <br /><br />　　当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 <br /><br />　　变量计数之二：<br />　　(1) x=1; <br /><br />　　(2) for(i=1;i&lt;=n;i++) <br /><br />　　(3) for(j=1;j&lt;=i;j++) <br /><br />　　(4) for(k=1;k&lt;=j;k++) <br /><br />　　(5) x++; <br /><br />　　该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数： <br /><br />　　则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)。 <br /><br />　　（4）算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。 <br /><br />　　在数值A[0..n-1]中查找给定值K的算法大致如下： <br /><br />　　(1)i=n-1; <br /><br />　　(2)while(i&gt;=0&&(A[i]!=k)) <br /><br />　　(3) i--; <br /><br />　　(4)return i; <br /><br />　　此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: <br /><br />　　①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； <br /><br />　　②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。</p><br><p>标题为:冒泡排序法C++算法</p><p>内容为://以下就是C++冒泡排序<br />int* BubbleSort(int* ary, int length)<br />{<br />    int i, j, tmp;<br />    for(i=0; i&lt;length-1; i++)<br />    {<br />        tmp = ary[i];       <br />        for(j=length-1; j&gt;i; j--)<br />        {<br />            //找到数组中最小的数，并交换<br />            if(tmp &gt; ary[j])<br />            {<br />                ary[i] = ary[j];<br />                ary[j] = tmp;<br />                tmp = ary[i];<br />            }<br />        }<br />    }<br />    return ary;<br />}</p><br><p>标题为:平方的算法</p><p>内容为:60x40=2400平方厘米=0.24平方米<br /><br />0.24*300=72元</p><br><p>标题为:请问1+1有几种算法</p><p>内容为:1十1 等于多少？，这要看是从什么角度考虑。<br />在某些数制里，如八进制、十进制等，1+1等于2；<br />但是，在二进制里，1+1不是等于2，而是等于“10”；<br />也要看单位，1个+1个=2个，1个+1对=3个，1对+1对=4个，1个指头+1只手=6个指头，1天+1周=8天，1打+1个=13个……<br /><br />逻辑运算中，1+1=1<br /><br />文字游戏，一加一=十，=11，=王，=丰……；<br /><br />生活中，1堆土+1堆土=1堆土，1堆土+1桶水=1堆泥……<br />在社会里，如2人结婚，1+1=1（1个家庭），后生了一个小孩，可以认为1+1等于3；<br />在企业联合方面，如果是强强联合，则1+1大于2；如果是弱弱联合，则1+1小于于2。<br />在算错的情况下，等于任何数都可能。<br />……等。<br /><br />以上回答希望对你有所帮助。</p><br><p>标题为:算法的主要特征</p><p>内容为:算法是一个有穷规则的集合，这些规则确定了解决某类问题的一个运算序列。对于该类问题的任何初始输入值，它都能机械地一步一步地执行计算，经过有限步骤后终止计算并产生输出结果。归纳起来，算法具有以下基本特征： <br />　　(1) 有穷性：一个算法必须在执行有限个操作步骤后终止； <br />　　(2) 确定性：算法中每一步的含义必须是确切的，不可出现任何二义性；<br />　　(3) 有效性：算法中的每一步操作都应该能有效执行，一个不可执行的操作是无效的。例如，一个数被0除的操作就是无效的，应当避免这种操作。 <br />　　(4) 有零个或多个输入：这里的输入是指在算法开始之前所需要的初始数据。这些输入的多少取决于特定的问题。例如，例l-1的算法中有2个输入，即需要输入a和b两个初始数据，而例l-2的算法中则需要输入四个初始数据。有些特殊算法也可以没有输入。<br />　　(5) 有一个或多个输出：所谓输出是指与输入有某种特定关系的量，在一个完整的算法中至少会有一个输出。如上述关于算法的三个例子中，每个都有输出。试想，如果例1-3中没有 &quot;输出n的当前值&quot;这一步，这个算法将毫无意义。</p><br><p>标题为:什么是启发式算法</p><p>内容为:大自然是神奇的，它造就了很多巧妙的手段和运行机制。受大自然的启发，人们从大自然的运行规律中找到了许多解决实际问题的方法。对于那些受大自然的运行规律或者面向具体问题的经验、规则启发出来的方法，人们常常称之为启发式算法（HeuristicAlgorithm）。现在的启发式算法也不是全部来自然的规律，也有来自人类积累的工作经验。驾驶汽车到达某人的家，写成算法是这样的：沿167 号高速公路往南行至阳谷；从阳谷高速出口出来后往山上开4.5 英里；在一个杂物店旁边的红绿灯路口右转，接着在第一个路口左转；从左边褐色大房子的车道进去，就是某人的家。启发式方法来描述则可能是这样：找出上一次我们寄给你的信，照着信上面的寄出地址开车到这个镇；到了之后你问一下我们的房子在哪里。这里每个人都认识我们——肯定有人会很愿意帮助你的；如果你找不到人，那就找个公共电话亭给我们打电话，我们会出来接你。</p><br><p>标题为:prim算法和kruskal算法的区别</p><p>内容为:边数较少可以用Kruskal,因为Kruskal算法每次查找最短的边。 边数较多可以用Prim，因为它是每次加一个顶点，对边数多的适用。</p><br><p>标题为:如何实现抽签算法</p><p>内容为:首先，你的数据库的user表需要存储报名人的id，是否参加第一次抽签（first）第一次抽签是否抽中（first_row），是否参加第一次抽签（second）,第二次抽签是否抽中（second_row），和报名人的基本信息（name，password......）。<br /><br />然后进行报名注册(报名的同时first=1，second=0)，当第一次报名时间截止，如果第一次报名人数超过50人时抽签，被抽到的人first_row=1。<br /><br />然后进行第二次报名注册，第一次没有抽中的人（second_row==0）登录时可以选择是否报名(second=1),当第二次报名时间截止，所有second==1的用户抽签，抽中者second_row=1。</p><br><p>标题为:韩国年龄的算法</p><p>内容为:韩国人在计算年龄上面是把在妈妈肚子里的一年也加上的，所以按韩国的算法都比中国的“周岁”多算一岁，而跟中国的“虚岁”相同。而且在韩国以3月划分为大小月，这跟中国的“阴历”算法相近，即如果某人是3月（阴历的正月）以后的，那么就还是按他是当年生的；<br /><br />如果某人是3月以前的，那么就按他是出生那年的上一年生的，因此就又加一岁。<br /><br />从年龄算法上可以看出韩国文化受中国古代文化的影响。</p><br><p>标题为:加班费的算法</p><p>内容为:　　根据《中华人民共和国劳动法》第四十四条有关规定：有下列情形之一的，用人单位应当按照下列标准支付高于劳动者正常工作时间工资的工资报酬：<br />　　（一）安排劳动者延长工作时间的，支付不低于工资的百分之一百五十的工资报酬；<br /><br />　　（二）休息日安排劳动者工作又不能安排补休的，支付不低于工资的百分之二百的工资报酬；<br /><br />　　（三）法定休假日安排劳动者工作的，支付不低于工资的百分之三百的工资报酬。</p><br><p>标题为:算法与程序的关系是什么？</p><p>内容为:此次没有获取到</p><br><p>标题为:在算法正确性的基础上，算法设计的首要目的是？</p><p>内容为:最小化算法复杂度，分为空间复杂度和时间复杂度。简单说就是在算法能够得到正确结果的前提下，算法运行占用的存储越少越好，算法执行时间越小越好。</p><br><p>标题为:Runge--kutta算法</p><p>内容为:此次没有获取到</p><br><p>标题为:个人所得税的算法</p><p>内容为:按照国家最新修订的《个人所得税法》，个税起征点确定为3500元，适用超额累进税率为3%至45%。7级超额累进税率如下表： <br /> <br />全月应纳税所得额	 税率	 速算扣除数(元)<br /> 全月应纳税额不超过1500元	 3%	 0<br /> 全月应纳税额超过1500元至4500元	 10%	 105<br /> 全月应纳税额超过4500元至9000元	 20%	 555<br /> 全月应纳税额超过9000元至35000元	 25%	 1005<br /> 全月应纳税额超过35000元至55000元	 30%	 2755<br /> 全月应纳税额超过55000元至80000元	 35%	 5505<br /> 全月应纳税额超过80000元	 45%	 13505<br /> <br />个税的具体算法： <br />1、确定税率及速算扣除数<br />在上面的7级超额累进税率表中，找到相对应的税率及对应速算扣除数<br />2、算出纳税额度<br />纳税额度＝月收入（扣除三险后的）- 3500元（个税起征点）   <br />3、算出个税<br />个税＝应纳税额×对应的税率-速算扣除数</p><br><p>标题为:什么是百度算法？</p><p>内容为:说的简单点，就是指百度公司对于网站排名的一种计算公式。<br /><br />从事SEO工作的人，想认识学习SEO，可以加群，群号前面137中间303后面464。特别是新手站长，没有人指导的话，很容易走歪，自学SEO是比较难的，需要专业系统的学习。<br />2016百度搜索算法大盘点<br />6月：打击欺骗下载和无告知的捆绑下载。<br />7月：冰桶3.0，打击移动页强制用户下载或调起APP的行为。<br />8月：天网，打击网站窃取用户信息，在网页嵌恶意代码，用于盗取网民的QQ号、手机号等隐私行为。<br />9月：冰桶4.0，百度搜索针对移动搜索结果页广告过多、影响用户体验的页面，进行策略调整，冰桶算法4.0特打击此类站点。<br />11月：蓝天，蓝天算法主要打击新闻源站点售卖软文、目录行为。</p><br><p>标题为:韩国的年龄算法，</p><p>内容为:首先是要加上在妈妈肚子里的那一年 <br /><br />其次就是每年的三月一日为划分线的   <br />在这年三月一日以前出生的加两岁，  <br />在这年三月一日以后出生的加一岁。  <br />有的亲不太明白..举例子..  <br />比如你88年2月1号的..实际21岁..因为是3月一号以前.加2岁..恭喜..您23了  <br />比如你88年4月1号的...实际也21岁...但是因为是3月1号以后..加1岁..您现在22岁.  <br />就是这样啦  <br />所以这就是为什么有的人说出来的岁数比虚岁还大了</p><br><p>标题为:住房公积金的算法</p><p>内容为:每月住房公积缴存额由职工本人缴纳和单位为职工缴纳二部分组成，其计算方法是以&quot;本人上一年度月平均工资&quot;为基数和政策规定的缴存比例得出。即：<br />   (1)职工本人住房公积金的月缴存额 = 职工本人上一年度月平均工资×职工住房公积金缴存比例;<br />   (2)单位为职工缴存的住房公积金的月缴存额 = 职工本人上一年度月平均工资×单位住房公积金缴存比例。<br />   职工本人上一年度月平均工资同，同当地社会平均月平均工资之比，低于60%的最低按当地社会平均月平均工资的60%计算，高于300%，最高按300%计算。<br />   缴存比例（各地可能有差异）。不实行住房补贴制度的地区和用人单位，以增加住房公积金缴存比例方式实行住房分配货币化改革的，可适当提高缴存比例，但最高不超过20%。</p><br><p>标题为:【印度式计算法】在网上发现了从11至19的算法，但是超过20就不管用了，再大一点的数字还有没有好办法？</p><p>内容为:那个不知道个说！貌似速算。给你速算的看看吧 也不知道有没有用！<br /><br />十几乘十几： <br />口诀：头乘头，尾加尾，尾乘尾。 <br />例：12×14=？ <br />解: 1×1=1 <br />   2＋4＝6 <br />   2×4＝8 <br />    12×14=168 <br />注：个位相乘，不够两位数要用0占位。 <br /><br />  2.头相同，尾互补(尾相加等于10)： <br />口诀：一个头加1后，头乘头，尾乘尾。 <br />例：23×27=？ <br />解：2＋1＝3 <br />  2×3＝6 <br />  3×7＝21 <br />    23×27=621 <br />注：个位相乘，不够两位数要用0占位。 <br /><br />  3.第一个乘数互补，另一个乘数数字相同： <br />口诀：一个头加1后，头乘头，尾乘尾。 <br />例：37×44=？ <br />解：3+1=4 <br />    4×4=16 <br />    7×4=28 <br />     37×44=1628 <br />注：个位相乘，不够两位数要用0占位。 <br /><br />  4.几十一乘几十一： <br />口诀：头乘头，头加头，尾乘尾。 <br />例：21×41=？ <br />解：2×4=8 <br />    2+4=6 <br />    1×1=1 <br />    21×41=861 <br /><br />  5.11乘任意数： <br />口诀：首尾不动下落，中间之和下拉。 <br />例：11×23125=？ <br />解：2+3=5 <br />    3+1=4 <br />    1+2=3 <br />    2+5=7 <br />    2和5分别在首尾 <br />     11×23125=254375 <br />     注：和满十要进一。 <br /><br />  6.十几乘任意数： <br />               口诀：第二乘数首位不动向下落，第一因数的个位乘以第二因数后面每一个数字，加下一位数，再向下落。 <br />例：13×326=？ <br />解：13个位是3 <br />    3×3+2=11 <br />    3×2+6=12 <br />    3×6=18 <br />     13×326=4238 <br />       注：和满十要进一。</p><br><p>标题为:算法必须有输入和输出吗？</p><p>内容为:算法可以不要输入，算法按照自身的初始状态执行下去就可以了<br />算法必须要有输出，不然没有输出的话算法还有什么用呢？</p><br><p>标题为:1加到100是多少？详细算法</p><p>内容为:等差数列的和＝（首项＋末项）×项数÷2<br />即：（1+100）×100÷2＝5050</p><br><p>标题为:关于日工资的算法</p><p>内容为:按照现在的劳动法，每年365天，减去法定假日除以12，每个月的平均工作天数是21.75天。也就是说一个员工入职以后给他核定的工资除以21.75以后就是他的日工资额。<br /><br />不管这个月是28天还是31天，也不管这个月有几个公共假期，你只要在他的月工资基础上减去他实际未出勤（婚、丧、产假除外）的工作日对应的工资即可。<br /><br />如果员工是5月4日入职的，因为前三天是法定假日，所以不影响他拿满月工资。</p><br><p>标题为:O(n+m)的算法什么意思</p><p>内容为:算法渐进复杂度<br />指需要基本操作am+bn次.a,b为常数。<br />1、时间复杂度<br />  （1）时间频度 <br />  一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 <br />  （2）时间复杂度 <br />  在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 <br />  一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 <br />  在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=n^2+3n+4与T(n)=4n^2+2n+1它们的频度不同，但时间复杂度相同，都为O(n^2)。 <br />  按数量级递增排列，常见的时间复杂度有： <br />  常数阶O(1),对数阶O(log2n),线性阶O(n), <br />  线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),...， <br />  k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><br><p>标题为:什么是归约算法</p><p>内容为:此次没有获取到</p><br><p>标题为:8 8 8=6怎么算显示算法的</p><p>内容为:此次没有获取到</p><br><p>标题为:急求比例的算法！</p><p>内容为:求连比通常有两种情况：<br />  （1）如果甲数与乙数的比是a∶b，乙数与丙数的比是b∶c，那么甲、乙、丙三个数的连比为a∶b∶c。例：甲与乙的比是2∶3，乙数与丙数的比是3∶7，那么甲、乙、丙三数的连比为2∶3∶7。<br />   （2）如果甲与乙的比是a∶b，乙与丙的比是c∶d，则求甲、乙、丙三数的连比的方法是将第一个比的前项a和后项b同乘以第二个比的前项c，将第二个比的前项c和后项d都同时乘以第一个比中的后项b，使两个比中乙所代表的数相等。那么，甲、乙、丙三个数的连比是：ac∶bc∶bd。<br />如：甲和乙的比是4∶3，乙和丙的比是9∶7，求甲、乙、丙的连比。<br />（4×9）：（3×9）：（3×7）＝36：27：21＝12：9：7<br />又如：x:y=0.5:1/5 z:y=2/3:1/2 求x:y:z     <br />x:y=0.5:1/5=0.5:0.2=5:2=15:6<br />y:z=1/2:2/3=3:4=6:8<br />x:y:z=15:6:8<br />解比例主要应用比例的基本性质（组成比例的四个数，叫做比例的项。两端的两项叫做比例的外项，中间的两项叫做比例的内项。在比例里，两个外项的积等于两个内项的积）。<br />希望可以帮到你</p><br><p>标题为:蒙德卡罗算法</p><p>内容为:蒙特卡罗法（Monte Carlo method）是以概率和统计的理论、方法为基础的一种计算方法，将所求解的问题同一定的概率模型相联系，用电子计算机实现统计模拟或抽样，以获得问题的近似解，故又称统计模拟法或统计试验法。、<br /><br />参见百度百科</p><br><p>标题为:锦州麻将算法</p><p>内容为:　　锦州麻将<br />　　一、游戏术语：<br />　　局： 自起牌到胡牌或黄庄，打完一副牌，称为一局。<br />　　圈： 东、南、西、北各家各作一次庄称为一圈。<br />　　庄家： 门风为东者是庄家，按逆时针方向轮庄。<br />　　掌（将）：即两张同样的牌。标准麻将中的“将”，锦州麻将亦称为“掌”。<br />　　横： 三张一样的牌。<br />　　顺子： 同一门三张相连的牌，如一二三，五六七等。<br />　　吃： 上家打出牌后，把自己的两张牌取出加在一起组成顺子，并且按规定将此副牌摆亮在立牌左侧。<br />　　岔（碰）： 标准麻将中的“碰”，锦州麻将称为“岔”。<br />　　杠： 四张同样的牌落地称为“杠”。分明杠和暗杠两种：<br />　　明杠：岔后杠称为明杠。<br />　　暗杠：自己原有的四张牌过杠称暗杠。<br />　　彩杠：四张红中。 胡牌： 符合规定的牌型条件，就可以胡牌。<br />　　杠上开： 杠后牌为胡牌，则称为“杠上开”。<br />　　自摸和： 自己抓到能和的牌。<br />　　分张： 根据规则，玩家能抓到的最后四张牌。<br />　　黄庄（南方叫流局）：本局未有人胡牌；当还剩下最后的16张牌没有摸的时候，如果还没有任何一个玩家胡牌，则此局牌“黄庄”，也叫做“流局”。重新开始，但是庄家要赔庄。还是原有的庄家连续坐庄。<br />　　飘和： 胡牌时全部为横牌（即碰牌或岔牌）的牌型。<br />　　手把一： 飘和时手里只剩一张牌，称手把一。<br />　　海底捞： 分张时胡牌。<br />　　杠流泪：杠后出牌点炮。<br />　　二、胡牌规则：<br />　　麻将的玩家为4人，分别为东、南、西、北。<br />　　三、胡牌条件：<br />　　门齐（三色全）；l<br />　　已开门（吃过，或碰过，明杠过，暗杠不算）；l<br />　　l 有幺九；（如果缺幺九，将不能胡牌。但是用红中做掌或有红中岔可以缺幺九，即缺幺九可以胡牌）；<br />　　l 胡牌必须要有横，如果没有横，有一对中。也可以胡牌；<br />　　七对胡牌：胡牌时均为对牌；（允许别人点炮）l<br />　　l 闭门胡牌（也称站着胡）：未开门。<br />　　四、锦州麻将游戏规则：<br />　　一、需要的牌张<br />　　一条至九条 36张<br />　　一筒至九筒 36张<br />　　一万至九万 36张<br />　　红 中   4张<br />　　共计112张<br />　　每人面前摆放28张牌<br />　　二、杠牌<br />　　（1）明杠：有两种情况<br />　　第一、在打牌过程中，玩家自己手有三个一样的牌，其他玩家打出来这一张（在别的玩家没有胡的情况下）可以杠 ，这叫打明杠；<br />　　第二、玩家已经碰了牌后，又抓到了这张，可以杠，这叫抓明杠；<br />　　（2）暗杠：只有一种可能，就是自己抓到了四张一样的牌，然后把这四张扣下，别人看不到。<br />　　总之，无论明杠、暗杠、扣完后都要到尾牌抓一张，继续打牌。<br />　　三、黄庄<br />　　就是在一个玩家座庄时，没有人能够胡牌，所以叫“黄庄”，黄庄后，还由这个玩家继续座庄，无论要黄多少把，都由他来座庄。<br />　　注意：黄庄不是把牌都抓没，要在尾牌数出四落，不抓，也就是说这四落牌前面的两落牌（4张）就是玩家“海底捞月”（也叫海捞）的四张牌，每人一张，没有人胡就算黄庄，如果有人杠牌，尾牌出现单张，这一张牌不算，要数出整落的四落牌。<br />　　四、胡牌条件<br />　　不能缺门:也就是在胡的这一副牌里，必须有条、饼、万这三门，少一门都不能胡牌；<br />　　（2）不能缺幺九，就是在胡的牌里，必须要有幺或九，有一张即可，要连牌、碰、<br />　　（3）必须有碰牌<br />　　就是说要胡的一副牌里，至少要有一个副是三个一样的（杠也算）<br />　　注意：只有一种情况可以没有碰牌 就是红中做对时可以，下面会详细说明。<br /><br />　　（4）锦州麻将不能叫听，上听后也不需要其他玩家知道，同时也可以更换胡的牌张<br />　　（5）开不开门都可以胡．<br />　　（6）手里不能少于4张牌，也就是，吃，碰三套，手里剩4张，就不能再吃 碰（只有一种情况 手里可以剩一张，就是下面要说的飘单粘胡）<br />　　六、红中的特殊用途<br />　　在这112张牌里就4个红中是特殊牌，它的作用是很大的。<br />　　（1）红中可以杠；<br />　　（2）胡的牌里有它、没它都可以胡；<br />　　（3）它可以代表幺九<br />　　（4）它可以代表碰牌，有一对红中做对，基本什么都解决了，就是不能解决缺门的问题<br />　　七、胡牌的类别<br />　　两叫或多叫（一类胡）<br />　　对倒胡（一类胡）<br />　　夹胡（二类胡）<br />　　边胡（二类胡）<br />　　单粘胡（二类胡）<br /><br />　　单胡幺（二类胡）<br />　　对倒飘胡（三类胡）<br /><br />　　单粘飘胡（四类胡）只有这种胡才可以手把单儿，可以碰四碰，手里剩一张牌<br />　　七对胡（四类胡）<br />　　七对胡是不可能开门的 胡了必须要算开门胡<br />　　（10）豪华七对胡（五类胡）<br />　　豪华七对胡 和普通七对胡的区别是这副牌里有4张牌是一样的，所以胡起来要难上加难！<br />　　注意：七对胡是不能开门的  如果胡了只能算开门胡<br />　　八、胡牌方式<br />　　（1）自摸<br />　　（2）杠开花，在玩家上听后 出现杠的同时，从尾牌抓的那一张，正好是胡的牌<br />　　（3）海底捞月 快要黄庄时，每位玩家最后抓的一张牌 正好是自己要胡的牌 称为海底捞月。按摸牌的顺序分牌。<br />　　（4）点炮<br />　　（5）杠流泪，在玩家杠牌时，从尾牌抓完牌后，所打出的一张牌给其他玩家点炮了，为杠流泪<br />　　（6）抢杠，在玩家自摸杠时，摸到的杠牌，正好是其他玩家胡的牌，胡家就可以胡牌，（注：只有摸到杠的玩家将这张牌过杠了，才可以抢杠，同时，这个杠也就不算分了）<br />　　九、算分的方法<br />　　拟定基本分为2分，<br />　　1、胡牌起算分：一类胡为2分<br />　　二类胡为4分<br />　　三类胡为8分<br />　　四类胡为16分<br />　　五类胡为32分<br />　　2、其他加翻<br />　　（1）没有开门（闭门）注：就是不吃、不碰别人的牌，全靠自己摸，要X2<br />　　（2）四清要X2，注：就是四个玩家都没有开门<br />　　自摸要X2，杠开花要再X2，特别注意：红中杠开花还要再X2<br />　　（4）点炮要X2，抢杠要再X2，杠流泪要X2，注意：红中杠流泪还要再X2<br />　　座庄者X2<br />　　海底捞月要X2<br />　　以上几种情况同时出现，要累计X2<br />　　3、杠的算分方法<br />　　出现杠牌与胡牌不胡牌没有任何关系，都是单算，出现一个，算一个杠的分，<br />　　明杠的基本分数为4分，暗杠的基本分数为8分<br />　　（1）打杠（注：一个玩家给另一个玩家打出明杠要一家给）4X3＝12分<br />　　（2）自摸明杠（注：另外三个玩家都要给）4＋4＋4＝12分<br />　　（3）暗杠（注：暗杠肯定是自摸的杠，另外三家都要给）8＋8＋8＝24分<br />　　（4）打红中明杠（注：一个玩家给另一个玩家打出明杠要一家给）8X3＝24分<br />　　（5）自摸红中明杠（注：另外三个玩家都要给）8＋8＋8＝24分<br />　　（6）红中暗杠（注：暗杠肯定是自摸的杠，另外三家都要给）16＋16＋16＝48分<br />　　十、胡牌算分<br />　　1、自摸 杠开花和海底捞月要三家都给胡家分．<br />　　2、点炮、杠流泪、抢杠是一家把三家的分给胡牌的玩家．<br />　　也就是说，玩家把牌自己摸胡了，另外三家都要输分，那么玩家要是通过别的玩家点炮胡牌了（包括抢杠），那么胡家所赢三家的分，都由点炮者一人给。<br />　　3、黄庄算分法<br />　　在黄庄后，由座庄的玩家给其他三个玩家每人4分，然后，由这个玩家继续坐庄。<br />　　4、跟庄的算分法<br />　　所谓跟庄是指庄家第一张牌打出后，其他三个玩家后面每人打的牌和壮打的是一样的（指第一圈），这种情况发生后，庄家要给其他每人4分，接着第二圈再跟庄，庄要再给其他玩家每人8分，第三圈再跟庄 ，庄要再给其他玩家每人16分，如果跟庄是红中，那就X2。<br />　　比如，在第二圈跟庄是红中 那么庄给其他玩家每人的分数应该是16分（注意：只有第一圈开始跟庄，以后连续跟多少圈都成立。）<br />　　5、天胡<br />　　所谓天胡只有坐庄的玩家才能够出现，庄家抓完牌，一张都没打就胡牌，这样叫天胡，每个玩家要给庄家200分。</p><br><p>标题为:对python编程者来说最应掌握什么算法</p><p>内容为:此次没有获取到</p><br><p>标题为:关于毛利和毛利率的算法</p><p>内容为:毛利额是指毛利是商品实现的不含税收入减去其不含税成本的差额 ,具体公式:毛利额=主营业务收入总额-主营业务成本。他是个时期指标.随着时间的变化而变化.是一个绝对数<br />毛利率是用以反映企业每一元收入中含有多少毛利额，它是净利润的基础。具体公式：毛利率＝(主营业务收入总额-主营业务成本总额)／收入总额×100%，是表示的一个比值 ,是一个相对数,他反映获利能力.<br />区别:毛利额是个时期财务指标会随着时间变化而变化,一般是时间越长,毛利额越大;毛利率是一个相对指标,与时间变化没有关系,毛利率越高说明获利能力越强.</p><br><p>标题为:算法中int是什么意思？</p><p>内容为:INT函数<br />　　将数字向下舍入到最接近的整数，即取不大于自变量的最大整数，例如：int[6.4]=6 int[-9.7]= -10 　　语法 　　INT（number） 　　Number 需要进行向下舍入取整的实数。 　　示例 　　如果将示例复制到空白工作表中，可能会更易于理解该示例。 　　<br /> A <br />1 数据 <br />2 19.5 <br />　　公式 说明（结果） <br />=INT(8.9) 将8.9向下舍入到最接近的整数(8) <br />=INT(-8.9) 将-8.9向下舍入到最接近的整数(-9) <br />=A2-INT(A2) 返回单元格A2中正实数的小数部分(0.5)</p><br><p>标题为:农历的算法是怎么算的？</p><p>内容为:首先我复制粘贴的，还有就是算法复杂，如果你的心算能力强就会更快些！<br /><br />阳历日期推算阴历日期的方法：<br />阴历日期是以月亮的圆缺为计月单位，其以逢朔为初一，以月望为十五（大月为十六日），以月晦为二十九日（大月为三十日）。然而目前记时通常用阳历日期表达，如欲将阳历日期换算成阴历日期可以用以下两种方法：<br /><br />其一是查《新编万年历》，如查1984年6月8日是阴历几日？翻开万年历6月10日是阴历十一，则逆推6月8日是阴历初九。<br /><br />其二可以利用公式推算阴历日期： <br />设：公元年数－1977（或1901）＝4Q＋R <br />则：阴历日期=14Q+10.6(R+1)+年内日期序数-29.5n <br />（注:式中Q、R、n均为自然数，R&lt;4） <br />例：1994年5月7日的阴历日期为： <br />1994－1977＝17＝4×4＋1 <br />故：Q＝4，R＝1 <br />则：5月7日的阴历日期为： <br />14×4+10.6(1+1)+(31+28+31+31+7)-29.5n <br />=204.2- 29.5n <br />然后用29.5去除204.2得商数6......27.2，6即是n值，余数27即是阴历二十七日。 <br /><br />一、 推算年干支口诀 <br /><br />掌上推算年干支，支子花甲起根源。 <br />阳支都是旬开始，天干为甲尾四年。 <br />隔位逆推十年正，顺推年尾五零三。 <br />逐支加减六十数，掌上推算千万年。 <br /><br />推算方法：“掌上推算年干支，支子花甲起根源。”此法是将地支排列在掌中，手掌上推算年干支的方法。 首先，在掌上将地支定位（图一），然后以地支子位为花甲子的开始，可定为1864，1924，也可定为1984年???，其年都是甲子年。“阳支都是旬开始，天干为甲尾四年。”地支中的子，寅，辰，午，申，戌都是阳支，而且也是每旬的开始，天干都为甲，即甲子，甲戌，甲申，甲午，甲辰，甲寅，这些年的公历尾数均为四。“隔位逆推十年正，顺推年尾五零三。”天干十数，地支十二数，天干与地支组合天干每循环一次，地支总与下二支（旬空）。其中余下的第一支便是下旬的开始。我们从地支子位开始，隔一位逆推，即从子位逆推隔亥到戌，恰是甲戌旬的开始，再逆推隔一位酉至申为甲申旬开始，------年尾数都为四，年间隔都是十年。在确定旬开始以后，以该年尾数四为起点，从下支开始挨位顺推，其公历年尾数分别是5，6，8，9，0，1，2，3，而后又是下旬的开始。“逐支加减六十数，掌上推算千万年”掌握此法推算，如果将甲子年定为1984年，按口诀可知1994年为甲戌，2004年为甲申，2014年为甲午等。确定每旬开始的公历年数后，可根据需要顺推任何一年的干支，虽意性很大，可推千年万年的干支。 <br /><br />二、推算月、时干支口诀 <br /><br />天干五合前为主，月时干序一至五。 <br />年干隔数配寅月，日干配时本数身。 <br /><br />古往今来，年上起月，日上起时，是按天干五合的方法，分成五种情况，即甲、己之年（日）定月（时）的方法相同------。我们也采用这种方法，并一前一天干为主，即甲、己以甲为主，乙、庚以乙为主，------，配上序数甲为1，乙为2，丙为3，丁为4，戊为5（图二），成为推算月、时的固定序数。“年干隔位配寅月”，推算某年的月干，先看该年干与何干相合，然后按“天干五合前为主”的方法，查出该干的序数，并设此干为零，按序数隔干确定寅月的天干。如98年是戊寅，戊癸干合，戊年与癸年的天干相同，属于同一种定寅月天干法。五的序数尾5 ，从5 开始，隔己、庚、辛、壬、癸五天干到甲，就可以算出98年寅月的天干是甲，其他月的天干就好推算了。“日干配时本身数” ，此句推算方法与年干定寅月天干发基本相同，只是在确定日干合干以后，从合之干的前干本身算起，按序数查，到何干，便是该日子时的天干。如己日，己与甲同一类型，以甲干为主，甲的序数为“1”以本身配子时，该日子时的天干为甲，即甲子时。同样，癸日子时吧的天干，因戊癸合干，以五为主，序数为5，从5开始数到壬，癸日子时为壬子时。 <br /><br />二、 农历大小月卦口诀 <br /><br />一年上下两卦编，一七两月初爻安。 <br />阴大阳小编上卦，遇有闰月年十三。 <br />闰爻相邻爻间伏，确定年月按节算。 <br /><br />推算方法：此诀是为了掌握某年农历大小月的排列顺序和有否闰月而编的。“一年上下两卦编，一、七两月初爻安” ，在 正常情况下，农历每年为十二个月。我们可以将一至六月编为前卦，七至十二月编为后卦，几一年编为两卦，并以一月为前卦的处爻，七月为后卦的初爻。“阴大阳小编上卦，遇有闰月年十三”，我们将大月规定用用阴爻表示，小月用阳爻表示，按大小顺序用阴阳爻将一年编为两卦。遇到有闰月的年份就多出一个月，一年为十三个月。“闰年相邻爻间伏，确定年月按节算”。在出现有闰月的年份时，按闰月大小用阴阳爻表现出来，并标在 闰月的前后两月的爻位中间的左侧，如同伏卦一样，一看便知到闰几月，是大月还是小月。同时，提醒您农历年、的确定，不是按万年历编出的月份确定的，而是按节气确定的。如1998年，按上述方法可编成《井》和《坎》两卦，而今年闰5月为小月，上半年月卦符号为“： 。 ： 。 。 ： ”，下半年的月卦符号为“ = 丨 = = 丨 = ”，上半年卦第5、6爻间伏一阳爻，可知今年润五月为29天。 <br /><br />四、推算日干支口诀 <br /><br />推算日干支，可以按公历和农历两种方法推算。 <br /><br />⑴ 农历日干支推算口诀： <br />大小月卦记心间，正一干支起根源。 <br />大后干同地支冲，小后干支退一天。 <br />初一十三二十五，支同隔干一位算。 <br />推算方法：“大小月卦记心间，正一干支起根源。”农历的大月为30天小月为29天，固定不变。要推农历曰干支，先要按《农历大小月卦口诀》将推算之年编上两卦，以便在推算日千支时运。除此之外，还要记住农历正月初一日的干支，因为它是推算一年逐日的基础。“大后干同地支冲，小后干支退一天。”农历天干与地支组合，天干循环2.5次。根据这一规律，知道某月初一日干支，如果这个月是小月则应在干同支冲的情况下，干支各减一位，则是小月后下月初一日干支。如本月初一干支为己卯，这个月是大月，下月初一干支为己酉。如果这个月是小月，则下月初一干支应在己酉退一位后确定，即为戊申日。“初一十三二十五，支同干隔一位算。”此两句是在确定某月初一干支后，将这个月分成三个阶段，即初一至十二，十三至二十四二十五以后。初一、十三、二十五日在干支上也是有规律的。知道初一干支，只要将该日天干隔一位顺推，而地支不变。同理，知道十三日干支，支同干隔一位，也知道二十五日的干支。如初一日干支为甲子，则十三日干支为丙子，二十五日干支为戊子。掌握这个方法，就可以根据所推之日属于哪一段，便可以很快知道这天的干支了。 <br /><br />⑵公历日干支推算口诀: <br />元旦干支为根源，大小二月记心间。 <br />小月干同地支冲，大月上句加一天。 <br />申子辰年年为闰，干同支冲退一天。 <br />余年二月二十八，干同支冲退一天。 <br />月首十三二十五，支同隔干一位算。 <br />推算方法：“元旦干支为根源，大小二月记心间。”推算公历日干支，首先要记住元旦曰的干支。同时，还要知道大小月及二月的天数。公历大月为31天，小月为30天，其大小月是固定不变的，唯独二月有29天和28天之分。因此，要特别注意哪年二月为29天，那年二月为28天。“小月干同地支冲，大月上句加一天。”公历小月为30天，按农历大月推算口诀，我们知道本月初一日干支，与下月初一干支则是天干相同地支相冲。公历大月为31天，在小月干地相冲的基础上，干支各加一位数，即是大月后下月一日的干支。“申子辰年年为闰，干同支冲退一天。”经过研究，发现凡地支为申、子、辰的年为公历闰年，二月为29天。在推算3月1日干支时，可按农历小月后的日干支推算方法，即在干同地干冲的基础上，干支各减一位，则为3月丨日干支。“余年二月二十八，干同干冲退二天。”除地干为申子辰年二月29天，其它年二月均为28天。在知道2月1日干支后，按干同支冲规律，干支各减二位便是3月1日的干支。“月首十三二十五，支同干隔一位算。”月首，代表每月第1日。其推法与农历日干干诀后两句相同。 <br /><br />五．实例：推算1998年农历6月初10日午时的干支。 <br />⒈先按《农历大小月卦口诀》，将98年农历大小月，排上两卦，并标出闰月。同时，记住正月初一日和元旦日干支。 <br />⒉推算1998年的干支。我们按《推算年干支口诀》在手掌上将地支子位定为甲子，为1984年，并将大拇指按在地支子位上。按“隔位逆推十年正”，大拇指从甲戌94年开始顺推，即94年为甲戌，95年为乙亥，96为丙子，97年为丁丑，98年干支则为戊寅。 <br />⒊推算农历6月份干支。确定1998年戊寅干支以后，按《定月时干支诀》，戊干与癸干合以戊为主，戊的序数为5，将大拇指固定在戊位上。“年干隔位配寅月”，从戊位开始，将大拇指顺数，隔过天干，已，庚，辛，壬、癸五干到甲，便是98年正月的天干，即正月干支为甲寅，再从寅支开始，按甲，己，丙，丁，戊6月干支为己未。 <br />⒋推算6月初10日（公历8月1日）干支。 <br />⑴推算农历日干支。如前所述，98年大小月卦为《井》和《坎》。因为闰5月为29天，为阳爻，伏在《井》卦第5、6爻问，卦形为 =丨= 丨丨= 。 <br />因为要推算的是农历98年正月初一日干支为己亥，先用大拇指在手掌亥支上定位，然后按《农历日干支推算诀》中的“大后干同地支冲，小后干支退一天”的规定，逐月推算初1日的干支。正月为大，干同支冲，大拇指跳到巳位上，2月初1日干支为已巳；干同支冲各减1，大拇指跳到亥位后，再减1位，3月初1日干支为甲戌；3月为小，干同支冲各减1大拇指跳到辰支后退1位，4月初1日为癸卯；4月为大，干同支冲，大姆指跳到酉干，5月初1日为癸酉；5月为小，干同支冲各减1，大拇指跳到卯支再退1位，闰5月 初1日为壬寅。闰5月为小，干同支冲各减1，大拇指跳到申支后再退一位，六月初一干支为辛未。知道6月初1日的干支后，从此位顺推初10曰的干支为庚辰。 <br />⑵、推算公历8月1曰干支。 <br />98年干支为戊寅，年支不属于申子辰，故98年2月为28天。按《曰公历干支推算口诀》中“小月干同地支冲，大月上句加一天------，余年二月二十八，干同支冲退两天”的规律，逐月推算。98年干支戊申，大拇指定在申位上。1月为大，干同支冲加一天，大拇指由申位到跳到寅，加1支到卯，2月1日为己卯，2月28天，干同干冲退二天，大拇指跳到酉位退二支，3月1日为丁未；3为大，干同支冲加1天大拇指跳到丑进一位4月1日干支为戊寅；4月为小，干同干冲，大拇指跳到申位，5月1日干支为戊申；5月为大，干同支冲加1天，大拇指跳到酉位，7月1日干支为己酉；7月为大，干同支冲加1天，大拇指跳到卯进1位到辰，8月1日干支为庚辰。 <br />⒌推算农历6月初10（公历8月1日），该日干支为庚辰。我们按《定日时干支诀》知道，该日干庚与己相合，按“天干五合前为主”，以天干己来推算，己的序数为2，将大拇指定在天干己的位置上。“日干定时本身数”，大拇指从第二位到丙，可知庚辰日子时为丙子。将大拇指从丙子顺推到午年时，天干为壬，午时干支为壬午。 <br />经过在掌上推算年、月、日、时干支，可知98年农历6月初10日（公历8月1日）午时干支，分别为戊寅年己未月庚辰日壬午时。 <br /><br />六、需要注意的几个问题。 <br />⒈要在理解《冯氏掌上巧推年月日时干支法》的基础上，将巧记口诀和在掌上定位推算结合起来，并经常对照万年历进行推算，才可能达到熟练生巧，运用自如。 <br />⒉再运用此法时，应先制定一种表格，并随身携带，供推算年干支时使用。 <br />此表格如下： <br />年序号 本年大小月卦（闰） 立春月日时 正月初一日干支 元旦日干 支 <br />1988 ：丨：丨丨：：丨：：丨： 正月初八庚子日辰时 己亥 戊申 <br />1999 丨丨：丨丨：丨：：：丨： 腊月十九丁亥日未时 甲子 癸丑 <br />在推算逐日干支时，一定要注意大小月，分清干同支冲和干同干支冲加减的区别。 <br /><br />掌上巧推年月日时干支法（附录） <br /><br />一、 逐年推算元旦干支口诀 <br />欲推来年元旦日，先知今年日干支。 <br />申子辰支年为闰，干加六位支冲支。 <br />余年天干加五位，干冲退一便可知。 <br />推算方法：“欲推来年元旦日，先知今年日干支。”推算来年元旦日的干支，必须先知道今年元旦日的干支，并用大拇指在掌上定位。“申子辰干年为闰，干加六位支冲支。”凡年支临申子辰的为闰年，2月29天。推算下一年元旦日的干支，只要大拇指从今年元旦日支位，跳到相冲的地干支位上，而后天干顺加六位，便是来年元旦的干支。“余年天干加五位，干冲退一便可知。”除申子辰年外，其它年干2月均为28天。大拇指在掌上定好今年元旦日支位置，推算来年元旦干支时，将大拇指跳到相冲之支退一位，天干加上五位，即是来年元旦的干支。 <br /><br />二、逐年推算正月初一日干支口诀 <br />欲推来年正一月，先知今年日干支。 <br />常年退回小月数，闰月小数五六七。 <br />小六干同天隔三，迂五前句各加一。 <br />逢七支同天隔三，各退一位定无异。 <br />推算方法：“欲推来年正一月，先知今年日干支。”推算来年正月初一日的干支，必须先知道今年正月初一的干支。“常年退回小月数，闰月小数五六七。”常年，指没有闰月的年份。推算农历正月初一干支，要按《农历大小月卦口诀》，逐年编上两卦，以便确定某年的小月数。如果今年没闰月，求来年正月初一日干支。经过研究，凡有闰月之年小月数分别为五、六、七三种。“小六干同天隔三，迂五前句各加一。”闰月之年，如果小月数为六，来年正月初一日干支，于前一年初一日干支则是地支相同，而天干则顺隔三位。小月数为五的，按干同天顺隔三后干支各进一位，便是来年正月初一日干支。“逢七支同天隔三，各退一位定无异。”闰月之年小月数为七的，在确定当年正月初一日干支后，推算下一年正月初一日干支，只要按支同天顺隔三位后，干支各减一位，便时来年正月初一日干支。 <br /><br />三、 用卦象推算公历各月第一日干支法 <br />用卦象推算公历各月第一日的干支，主要是按公历大小月固定不便的实际，编上一个适用任何一年的卦象。然后按大小干支循环规律，进行推算各月第一日的干支。公历年大小月固定卦象，上半年是《未济》卦，下半年为《蹇》卦，其卦象如图三所示。在推算过程中，要特别注意二月，因为有28天和29天之分，所以在《未济》卦象的等二爻，标上闰年合非闰年字样，以便在推算时引起注意。在推算时，要将《公历曰干支推算口诀》做为依据，确定下月第一日干支，然后按“月首十三二十五，支同隔干一位算”，推算出所求之日干支。图三。 <br />6月 丨 一曰干同地支冲+1 12月 = 一日干同支冲 <br />5月 = 一日干同地支冲 11月 丨 一日干同支冲+1 <br />4月 丨 一日干同地支冲+1 10月 = 一日干同支冲 <br />3月 = 闰一日干同地支冲+1 09月 丨 一日干同支冲+1 <br />2月 丨 闰年2月29天，非一日干同支冲—2 08月 = 一日干同支冲+1 <br />非闰年2月28天，一日干同支冲+1 <br />1月 = 元旦日干支 07月 = 一日干同支冲 <br /><br />四、 用卦象推算农历各月初一日干支法 <br />农历大小月，其天数固定不变，即大月30天，小月29天。但是，由于大小月的排列不规则，因此要按《农历大小月卦口诀》先编上本年的上下半年的月卦。然后依据两个卦象，参考《农历日干支推算口诀》，在知道正月初一的日干支后，按“大后干同地支冲，小后干支退一天‘的规律，运用卦象来推算农历各月初一日的干支。经研究发现，农历相邻两月大小月的排列，共有四种类型，其推算逐月初一干支法如下： <br />⑴ 两小月相邻同支冲 ⑵ 两大 <br />— 下月干同支冲—1 = 下月干 <br />— 本月初一日干 = 本月初一日干支 <br />⑶大小月相邻 ⑷ 大小月相邻 <br />— 下月干同支冲 = 下月干同支冲—1 <br />= 本月初一日干支 — 本月初一日 <br />△ 实例：推算2001年各月初一干支 <br />⒈按《农历大小月卦口诀》，先将2001年编上月卦。上半年为“艮”卦，下半年为“既济”卦。 <br />⒉2001年正月初一日干支为丁亥。 <br />⒊推算时，要将1、2月，3、4月等相邻两月，与四种排列类型对照，然后按相同类型进行推算。 <br />⒋根据卦象，逐月进行推算。 <br />6月“ — ”干同支冲己酉 12月“ = ” 干同支冲—1辛巳 <br />5月“ — ”干同支冲—1己卯 11月“ — ” 干同支冲壬子 <br />闰4月“ — ”干同支冲丙戌 10月“ = ” 干同支—1壬午 <br />4月“ — ” 干同支冲—1丙辰 9月“ — ” 干同支冲葵丑 <br />3月“ — ” 干同支冲丁亥 8月“ = ” 干同支冲—1癸末 <br />2月“ — ” 干同支冲丁巳 7月“ — ” 干同支冲—1甲寅 <br />1月“ — ” 正月初一丁亥 <br />经过逐卦推算农历12月初一为辛巳。</p><br><p>标题为:请教关于扑克的算法</p><p>内容为:我代码已经写的有些眉目了，随机发牌已经写完，摆放算法在纸上画出来了应该没什么大问题，代码明天写，明天下班继续回来看看，应该能搞定。<br /><br />到时候思考过程我都会写出来，代码部分会放到我的baidu空间，敬请留意。<br /><br />回答者：风骚的可乐 - 千总 四级 12-13 01:40<br />----------------------------<br /><br />问题描述：<br /><br />打印3行，每行9张扑克，用户随机记录一张之后输入该扑克所在的行号（1-3）<br />程序打乱顺序两次，用户再输入所记录的扑克在新的矩阵中的行号，也是两次。<br />程序给出准确结果。<br /><br />--------------------------------------------------------------<br /><br />分析：<br /><br />假设：54张扑克对应54个整数，随机抽取27个排成矩阵。<br />假设：第i次打乱之后的矩阵为M(i)，用户第i次输入的行号为L(i)。这里i取1,2或3。<br /><br />进行第一次打乱，我们将得到用户输入的两个数，L(1)和L(2)。此时，我们需要保证同时在M(1)中第L(1)行，且在M(2)中第L(2)行的元素足够<br /><br />少，假如这时候满足条件的数组是A(1)，其中含元素N(1)个。<br />那么我们再进行第2次打乱，用户输入L(3)。那么这时候，我们要保证，同时在M(3)中第L(3)行，且在数组A(1)中的元素，有且仅有1个，也就<br /><br />是N(2)必须为1。<br /><br />--------------------------------------------------------------<br /><br />来看一个例子：<br /><br />假设有如下的整数矩阵<br />[1] [2] [3]<br />[4] [5] [6]<br />[7] [8] [9]<br />假定我记录了8，那么L(1)=3，那么程序应该知道，用户记录的数字要么是7，要么8，要么9。这时候需要把这3个数放到不同的3行里，这样下<br /><br />次用户输入行数就能确定两次的交集了。<br />看看这种移位：<br />[1] [5] [9]<br />[4] [8] [3]<br />[7] [2] [6]<br />如果拥护输入L(2)=2，程序将可以直接判定，第一次在{ 7,8,9 }中，且第2次在{ 4,8,3 }中的，必然是8这个数。<br />同理，我们也可以这样移位：<br />[1] [8] [6]<br />[4] [2] [9]<br />[7] [5] [3]<br />这样，用户的输入就应该是L(2)=1，判定方式同上类似。<br />可以得出结论，对于3*3的矩阵，可以通过2次判定得出结果。<br /><br />下面我们把结论推广到27个数：<br />假定有如下的9*3矩阵<br />[T1] [T2] [T3]<br />[T4] [T5] [T6]<br />[T7] [T8] [T9]<br />其中，Ti(i=1~9)分别是3*1的矩阵，我们可以通过L(1)和L(2)确定i，因为Ti只有1行3个数，所以后面可以直接通过以上的“按列移位”方法来<br /><br />确定具体是哪个数。<br /><br />--------------------------------------------------------------<br /><br />下面给出测试代码，其中有部分变量和注释是没有实际意义的，如果你仔细看过，相信很容易将他们挑出来删除掉。<br /><br />代码说明：<br />(1) 为了方便，我没有将关键代码写成函数形式，如果写成函数形式的话会比较便于推广到n，而不仅仅局限于27个数。<br />(2) 为了方便，我没有写整数数组与扑克牌的转换代码，实际上这部分功能可以简单的通过数组对应来实现，请自行完成。<br />(3) 为了方便，代码中用到很多swap，实际上，应该使用自己编写的交换函数来实现这个功能，为了扩展方便，swap的参数已经被写成有规律<br /><br />的形式<br />(4) 调试环境：VC6_SP6+WinXP，转载请注明出处：<a href="http://hi.baidu.com/crazycola" target="_blank">http://hi.baidu.com/crazycola</a>，代码开放，抄袭可耻<br /><br />#include &lt;time.h&gt;<br /><br />#include &lt;iostream&gt;<br />#include &lt;cstdlib&gt;<br />#include &lt;iomanip&gt;<br /><br />using namespace std;<br /><br />void printArr(const int* pArr)<br />{<br />    for( int i=0; i&lt;3; i++ )<br />    {<br />        for( int j=0; j&lt;9; j++ )<br />            cout &lt;&lt; setw(3) &lt;&lt; pArr[i*9+j] &lt;&lt; &quot; &quot;;<br />        cout &lt;&lt; endl; // 抄袭可耻<br />    }<br />}<br /><br />void main()<br />{<br />    int line = 0;<br /><br />    srand( (unsigned)time( NULL ) );<br />    int *iArr = new int[27];<br /><br />    int tag = 0;<br />    for( int i1=0; i1&lt;27; i1++ )<br />    {<br />        char cola_temp1 = &#39;x&#39;; // when you just copy this without going through<br />        iArr[i1]=1+rand()%54; // you&#39;ll be dammed<br />        if( i1==0 ) continue;<br />        do {<br />            tag = 0;<br />            for( int j=0; j&lt;i1; j++ )<br />                if( iArr[j] == iArr[i1] )<br />                {<br />                    iArr[i1]=1+rand()%54;<br />                    tag = 1;<br />                }<br />        } while( tag==1 );<br />        // cout &lt;&lt; iArr[i1] &lt;&lt; endl;<br />    }<br /><br />    printArr(iArr);<br />    char cola_temp2 = &#39;t&#39;;<br />    cin &gt;&gt; line; // first<br /><br />    int *iArr2 = new int[9];<br />    for( int i3=0; i3&lt;9; i3++ )<br />        iArr2[i3] = iArr[(line-1)*9+i3]; // aha, it&#39;s sunny outside<br /><br />    swap(iArr[ 0*9+ 3],iArr[ 1*9+ 3]); swap(iArr[ 0*9+ 4],iArr[ 1*9+ 4]); swap(iArr[ 0*9+ 5],iArr[ 1*9+ 5]); <br />    swap(iArr[ 0*9+ 3],iArr[ 2*9+ 3]); swap(iArr[ 0*9+ 4],iArr[ 2*9+ 4]); swap(iArr[ 0*9+ 5],iArr[ 2*9+ 5]); <br /><br />    swap(iArr[ 0*9+ 6],iArr[ 2*9+ 6]); swap(iArr[ 0*9+ 7],iArr[ 2*9+ 7]); swap(iArr[ 0*9+ 8],iArr[ 2*9+ 8]); <br />    swap(iArr[ 0*9+ 6],iArr[ 1*9+ 6]); swap(iArr[ 0*9+ 7],iArr[ 1*9+ 7]); swap(iArr[ 0*9+ 8],iArr[ 1*9+ 8]); <br /><br />    printArr(iArr);<br />    cin &gt;&gt; line; //second<br /><br />    int smallMatrixFoot = -1;<br />    int *iArr3 = new int[3];<br />    char cola_temp3 = &#39;5&#39;; // 抄袭可耻<br />    for( int i4=0,k=0; i4&lt;9; i4++ )<br />        for( int j=0; j&lt;9; j++ )<br />            if( iArr2[j]==iArr[(line-1)*9+i4] )<br />            {<br />                if( k==0 ) smallMatrixFoot = (line-1)*9+i4; // save for future use<br />                                                            // smallMatrixFoot % 9 = col_num, and ( smallMatrixFoot - col_num <br /><br />) / 9 = row_num<br />                iArr3[k++] = iArr2[j];<br />            }<br />    // -- start: for test only<br />    /*for( int dbg01=0; dbg01&lt;3; dbg01++ )<br />        cout &lt;&lt; iArr3[dbg01] &lt;&lt; &quot; &quot;;<br />    cout&lt;&lt;endl;*/<br />    // --end:  for test only<br /><br />    int col_num = smallMatrixFoot % 9;<br /><br />    swap(iArr[ 0*9+col_num+1],iArr[ 1*9+col_num+1]); swap(iArr[ 0*9+col_num+1],iArr[ 2*9+col_num+1]); <br />    swap(iArr[ 0*9+col_num+2],iArr[ 2*9+col_num+2]); swap(iArr[ 0*9+col_num+2],iArr[ 1*9+col_num+2]); <br /><br />    printArr(iArr);<br />    char cola_temp = &#39;0&#39;;<br />    cin &gt;&gt; line; //third<br /><br />    int bingo = -1;<br /><br />    for( int i5=0; i5&lt;3; i5++ )<br />        if( iArr3[i5]==iArr[(line-1)*9+col_num+i5] )<br />            bingo = iArr3[i5]; // i&#39;m not so happy<br />        // -- start: for test only<br />        /*else<br />            cout &lt;&lt; iArr3[i5] &lt;&lt; &quot;!=&quot; &lt;&lt; iArr[line*9+col_num+i5] &lt;&lt; endl;*/<br />        // --end:  for test only<br /><br />    cout &lt;&lt; endl &lt;&lt; &quot;wow, you&#39;ve remembered &quot; &lt;&lt; bingo &lt;&lt; &quot; !&quot; &lt;&lt; endl;<br /><br />    delete [] iArr3; iArr3 = NULL;<br />    delete [] iArr2; iArr2 = NULL;<br />    delete [] iArr; iArr = NULL; // 抄袭可耻<br />}</p><br><p>标题为:G网 M算法和K算法和L算法有什么区别</p><p>内容为:M算法、L算法和K算法就是定位算法中三个典型步骤的算法。K算法是根据信号强度强弱为依据，L算法是以损耗为依据的，M算法以信号强度条件为依据的。<br />1）K算法是指在对服务小区以及相邻小区进行排队时(Basic Ranking),以信号强度作为排队标准。在排队时，K值越高的小区（信号强度越强）越排在前面。<br />2）L算法是指在对服务小区以及相邻小区进行排队时(Basic Ranking),以路径损耗(Path Loss)作为排队标准。引入L算法的目的是手机尽量选择距离较近的基站，以降低整个网络的干扰水平。在排队时，L值越低的小区（路径损耗越小）越排在前面。<br />3）M算法用于检查邻小区是否有资格进入Basic Ranking阶段。如果邻小区能进入Basic Ranking阶段，则信号强度必须同时满足以下两个条件：1. SS_DOWNn ≥ MSRXMIN；2. SS_UPn ≥ BSRXMIN</p><br><p>标题为:指出用中点算法和Bresenham算法扫描转换像素点（8，6）到（1，1）的线段时的像素</p><p>内容为:此次没有获取到</p><br><p>标题为:先来先服务调度算法的思想是什么</p><p>内容为:先来先服务(FCFS: first come first service)总是把当前处于就绪队列之首的那个进程调度到运行状态。也就说，它只考虑进程进入就绪队列的先后，而不考虑它的下一个CPU周期的长短及其他因素。FCFS算法简单易行，但性能却不大好。</p><br><p>标题为:算法的有穷性是指（ ）</p><p>内容为:此次没有获取到</p><br><p>标题为:什么是DEA算法</p><p>内容为:　　数据加密算法（Data Encryption Algorithm，DEA）是一种对称加密算法，很可能是使用最广泛的密钥系统，特别是在保护金融数据的安全中，最初开发的DEA是嵌入硬件中的。通常，自动取款机（Automated Teller Machine，ATM）都使用DEA。它出自IBM的研究工作，IBM也曾对它拥有几年的专利权，但是在1983年已到期后，处于公有范围中，允许在特定条件下可以免除专利使用费而使用。1977年被美国政府正式采纳。<br />　　数据加密标准DES<br /><br />　　DES的原始思想可以参照二战德国的恩格玛机，其基本思想大致相同。传统的密码加密都是由古代的循环移位思想而来，恩格玛机在这个基础之上进行了扩散模糊。但是本质原理都是一样的。现代DES在二进制级别做着同样的事：替代模糊，增加分析的难度。<br /><br />　　加密原理<br />　　DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。<br /><br />　　基本原理<br /><br />　　?基本原理<br />　　入口参数有三个:key、data、mode。 key为加密解密使用的密钥，data为加密解密的数据，mode为其工作模式。当模式为加密模式时，明文按照64位进行分组，形成明文组，key用于对数据加密，当模式为解密模式时，key用于对数据解密。实际运用中，密钥只用到了64位中的56位，这样才具有高的安全性。<br /><br />　　密钥生成<br />　　取得密钥<br />　　从用户处取得一个64位(本文如未特指，均指二进制位))长的密码key ,去除64位密码中作为奇偶校验位的第8、16、24、32、40、48、56、64位,剩下的56位作为有效输入密钥</p><br><p>标题为:正确的星座算法</p><p>内容为:　　按阳历，<br />　　如果只知道阴历出生日期，可先到这里换算成阳历生日再输入资料。<br /><br />　　白羊座：3月21日～4月20日<br /><br />　　金牛座：4月21日～5月21日<br /><br />　　双子座：5月22日～6月21日<br /><br />　　巨蟹座：6月22日～7月22日<br /><br />　　狮子座：7月23日～8月23日<br /><br />　　处女座：8月24日～9月23日<br /><br />　　天秤座：9月24日～10月23日<br /><br />　　天蝎座：10月24日～11月22日<br /><br />　　射手座：11月23日～12月21日<br /><br />　　魔羯座：12月22日～1月20日<br /><br />　　水瓶座：1月21日～2月19日<br /><br />　　双鱼座：2月20日～3月20日<br /><br />　　因为太阳每年进入各个星座的时间略有差别，如果你的生日在交界日附近，不好确定的话，请到这里输入你的出生资料绘制出你的个人星盘，其中太阳所在的星座就是通常我们所说的星座。<br /><br />　　四分法<br /><br />　　将星座按火、地、风、水分为四类<br /><br />　　火相星座：白羊座、狮子座、射手座<br /><br />　　地相星座：金牛座、处女座、魔羯座<br /><br />　　风相星座：双子座、天秤座、水瓶座<br /><br />　　水相星座：巨蟹座、天蝎座、双鱼座<br /><br />　　火相星座的人精力充沛，感情奔放激烈，有十足的行动力，但来的快去的也快，有时较草率和粗心。地相星座的人慎重、冷静，对待感情真诚持久，做事也脚踏实地，但有时过于保守和自信心不强。风相星座的人思维发达，想象力丰富，有思想家的倾向，擅长社交，语言表达能力强，但性格变化多端，有喜新厌旧和情绪化的毛病。水相星座的人温柔宁静、感情细腻，对事物的洞察力极强，直觉也很敏感，但有时想法不切实际且喜凭感情用事。<br />　　一般来说，火、地、风、水四种类别中，火和风相处较好，地和水相处不错。俗话说：风助火势。风相星座的人冷静、理性，火相星座的人热情、冲动，这两种人在一起时，风相星座的人往往以理性辅助火相星座的人，在行动上也经常给与指导。地相星座的人在感情方面稳重、持久，水相星座的人在感情方面由于过分敏感而情绪波动较大，于是地相星座的人往往关怀、安慰水相星座的人，在感情上就形成了一种辅助关系。<br /><br />　　另外我赠送你其他2个星座分配法:<br />　　一、二分法<br /><br />　　将星座按阳性和阴性分为两类：<br /><br />　　阳性：白羊座、双子座、狮子座、天秤座、射手座、水瓶座。<br /><br />　　阴性：金牛座、巨蟹座、处女座、天蝎座、魔羯座、双鱼座<br /><br />　　阳性星座的人大多是有进取心的、积极主动的理想主义者。<br /><br />　　阴性星座的人大多是性格内向的、被动的战略家。<br /><br />　　二、三分法<br /><br />　　将星座按本位型、固定型、变通型分为三类：<br /><br />　　本位型：白羊座、巨蟹座、天秤座、魔羯座，这类星座属于领导者型。<br /><br />　　固定型：金牛座、狮子座、天蝎座、水瓶座，这类星座属于组织者型。<br /><br />　　变通型：双子座、处女座、射手座、双鱼座，这类星座属于传授者型。<br /><br />　　在这三种分类中以四分法最为常用，因其包含了二分法(火相、风相为阳性，地相、水相为阴性)，其展现也较明显，可作为一般人的基本分类法。</p><br><p>标题为:什么是现金流折算法？</p><p>内容为:现金流折算法（Discounted Cash Flow/DCF）的基本假设是，一个公司的当前价值等于它在“未来”能带给投资人的现金流之“和”。这句话有两个关键词，一，它计算的是“未来”的现金流，不是过去的现金流。二，“和”并不是把未来现金流简单相加，而是先贴现（把将来的现金折算到今天）后再相加。<br />贴现的原因基于金钱的时间价值特性，即，数目相等但所处时间不同的金钱，其价值并不相同。这和“时间就是金钱”的说法相吻合。举例说来，把100元存入银行，如果利息为3%，那么一年后可以拿回103元（本金100+利息3）。从这个角度，今年的100元就等于明年的103元。反之，明年的103元贴现到今天就变成了100元。<br /> 现金流折现法就是把以后各年的现金流量折算成现在的价值,然后再于原始投资比较,大于原始投资(大于0),该方案可行,小于0,不可行 <br />比如现在投资5万元,以后5年都有2万元的收入,同期银行存款利率是6%,问你是否进行投资 <br />5年都有2万元的收入相当于现在的价值=2*(P/A,6%,5)=2*4.1002=8.2004 <br />由于大于原始投资,故该方案可行</p><br><p>标题为:大一新生，软件开发，如何自学算法</p><p>内容为:　　如果是想通过计算机等级考试 就买一本全国计算机等级考试二级试题认真做就可以了 当然也要加强上机实践。<br /><br />　　怎样才能学好C语言<br /><br />　　第一：C语言语法结构很简洁精妙，写出的程序也很高效，很便于描述算法，大多数的程序员愿意使用C语言去描述算法本身，所以，如果你想在程序设计方面有所建树，就必须去学它。<br />　　第二：C语言能够让你深入系统底层，你知道的操作系统，哪一个不是C语言写的？所有的indows, Unix, Linux, Mac, os/2，没有一个里外的，如果你不懂C语言，怎么可能深入到这些操作系统当中去呢？更不要说你去写它们的内核程序了。<br />　　第三：很多新型的语言都是衍生自C语言，C++,Java,C#,J#,perl...哪个不是呢？掌握了C语言，可以说你就掌握了很多门语言，经过简单的学习，你就可以用这些新型的语言去开发了，这个再一次验证了C语言是程序设计的重要基础。还有啊，多说一点：即使现在招聘程序员，考试都是考C语言，你想加入it行业，那么就一定要掌握好C语言。<br /><br />　　那么究竟怎样学习C语言呢？<br /><br />　　1：工欲善其事，必先利其器<br />　　这里介绍几个学习C语言必备的东东：<br />　　一个开发环境，例如turbo C 2.0,这个曾经占据了DOS时代开发程序的大半个江山。但是现在windows时代，用turbo C有感觉不方面，编辑程序起来很吃力，并且拖放，更没有函数变量自动感应功能，查询参考资料也不方便。建议使用Visual C++,这个东西虽然比较大块头，但是一旦安装好了，用起来很方便。<br />　　一本学习教程,现在C语言教材多如牛毛，但推荐大家使用《C语言程序设计》谭浩强主编 第二版 清华大学出版社，此书编写的很适合初学者，并且内容也很精到。<br />　　除此以外，现在有很多辅助学习的软件，毕竟现在是Window时代了，学习软件多如牛毛，不象我们当初学习，只有读书做题这么老套。我向大家推荐一个“集成学习环境(C语言)”，里边的知识点总结和例程讲解都非常好，还有题库测试环境，据说有好几千题，甚至还有一个windows下的trubo C，初学者甚至不用装其它的编译器，就可以练习编程了,非常适合初学者。还有一个“C语言学习系统”软件，不过感觉只是一个题库系统，如果你觉得题做的不够，不妨也可以试试。<br /><br />　　2：葵花宝典<br />　　学习计算机语言最好的方法是什么？答曰：读程序。<br />　　没错，读程序是学习C语言入门最快，也是最好的方法。如同我，现在学习新的J#,C#等其他语言，不再是抱着书本逐行啃，而是学习它们的例程。当然，对于没有学过任何计算机语言的初学者，最好还是先阅读教程，学习完每一章，都要认真体会这一章的所有概念，然后不放过这一章中提到的所有例程，然后仔细研读程序，直到每一行都理解了，然后找几个编程题目，最好是和例程类似的或一样的，自己试图写出这段已经读懂的程序，不要以为例程你已经读懂了，你就可以写出和它一样的程序，绝对不一定，不相信你就试一试吧，如果写不出来，也不要着急，回过头来再继续研究例程，想想自己为什么写不出来，然后再去写这段程序，反反复复，直到你手到擒来为止，祝贺你，你快入门了。<br /><br />　　3：登峰造极<br />　　写程序的最高境界其实就是掌握各种解决问题的手段(数据结构)和解决问题的方法(算法)。<br />　　是不是写出底层程序就是程序设计高手呢？非也，写底层程序，无非是掌握了硬件的结构，况且硬件和硬件还不一样，要给一个芯片写驱动程序，无非就是掌握这块芯片的各种寄存器及其组合，然后写值读值，仅此而已。这不过是熟悉一些io函数罢了。那么怎样才算精通程序设计呢？怎样才能精通程序设计呢？举个例子：你面前有10个人，找出一个叫“张三”的人，你该怎么办？第一种方法：直接对这10个人问：“谁叫张三”。第2种方法：你挨个去问“你是不是张三？”，直到问到的这个人就是张三。第三种方法：你去挨个问一个人“你认不认识张三，指给我看”。不要小看这个问题，你说当然会选第一种方法，没错恭喜你答对了，因为这个方法最快，效率最高，但是在程序设计中找到解决问题的最优方法和你用的手段却是考验一个程序员程序设计水平的重要标志，而且是不容易达到的。刚才这个问题类似于数据结构和算法中的：Map数据结构，穷举查找和折半查找。所以掌握好数据结构和一些常用算法，是登峰造极的必然之路。最后给大家推荐严尉敏的《数据结构》清华大学出版社，希望每一个想成为程序设计高手的人研读此书。</p><br><p>标题为:算法的时间代价</p><p>内容为:随便解释一下 ，解释的不好见谅<br />一个算法是解决某个问题的，比如n条数据排序问题，那么对于这个问题“n”就是它的问题规模<br />那么解决这个问题的算法的代价一定是n的函数，记为T(n)<br />为了比较不同算法之间的优劣，必须有一种方法将计算代价的函数进行变换，所以提出一种<br />概念叫做“复杂度”（好像是这么个意思,教材上的那个阴文单词背不出了)<br />记作T(n)=O(f(n)),表示代价T(n)和f(n)一样<br />比方说一个算法用时T(n)=n天 ，另一个算法用f(n)=100n天，可以证明<br />n=O(100n),那么就认为两个算法复杂度相同（1天和100天复杂度还相同,....)<br /><br />搂住的后半句就是具体定义，“存在正常数C和N,当问题规模n&gt;N时,有T(n)&lt;=Cf(n)”意思就是说如果有一个正的常数C，和一个正的常数N，当n&gt;N  不等式T(n)&lt;=Cf(n)恒成立，就“称某算法的时间(或空间)代价T(n)=O(f(n))”<br /><br />比如一个算法的代价是T(n)=100n ，那么当n&gt;=1时，100n &lt;= 101 n<br />那么就可以记作<br />T(n)=100n = O（n） 这里f(n)是f(n)=n，C=101，N=1</p><br><p>标题为:二进制的计算方法</p><p>内容为:二进制的或运算：遇1得1<br />二进制的与运算：遇0得0<br />二进制的非运算：各位取反<br />加法法则： 0+0=0，0+1=1+0=1，1+1=10<br />减法，当需要向上一位借数时，必须把上一位的1看成下一位的（2）10。<br />减法法则： 0-0 =0，1-0=1，1-1=0，0-1=1 有借位，借1当(10) 看成 2 则 0 - 1 - 1 = 0 有借位 1 - 1 - 1 = 1 有借位。<br />乘法法则： 0×0=0，0×1=0，1×0=0，1×1=1<br />除法应注意： 0÷0 =0(无意义)，0÷1 =0，1÷0 =0(无意义)<br />除法法则： 0÷1=0，1÷1=1</p><br><p>标题为:求助翻译：&quot;使用VC编程实现...算法&quot;用英语怎么说？</p><p>内容为:Implement the ... algorithm with VC (programming) <br />“实现”和“算法”的专业词汇就是implement和algorithm，尽量不要用其它说法<br /><br />implement the reconstruction of 3-D medical imageS with VC programming<br />这里image应该用复数<br /><br />这个系统是用Visual Studio 2005开发的：<br />This system was developed with Visual Studio 2005</p><br><p>标题为:算法导论是看英文版还是中文版</p><p>内容为:建议读中文的。<br />分析：<br />1.《算法导论》是一本可谓“面面俱到”的书，其中对算法的证明占了很大的比重，这在一般的算法书中并不多见，也是它严谨性的体现。中英文在理解上的区别也就在于如何引出这个算法、算法为什么正确上。但是这些证明虽然有重要意义，但是在实用价值上一般比不上算法本身。我自己在学习算法的时候都是先了解算法思想，再了解算法执行过程，再记住代码，然后做题，最后再来回顾导引和证明，即先知其然，再知其所以然。不能光知其然，那样无法掌握思想，思想才是精髓；而一上来就直奔证明，又缺乏学习效率。（也可能这只是我个人的特点）就算法执行过程本身，中英文都一样，而且由于伪代码本身并无区别，所以先读中文，以掌握算法。<br />2.当参加国际比赛的时候，题目都是用英文描述；当对算法的研究再上一个层次的时候，国内的译材已经不能够满足学习需要了。要想进步，达到高层次的领域，实现“出色”和“领先”，就一定要大量研读外国文献。这要求英语必须要好。<br />综上，我的建议是：读中文版《算法导论》，掌握算法，再看解释，理解它，才能更好地运用。学好英语，为达到更高的层次做准备。《算法导论》内容非常丰富，应该读好几遍，到时候再看英文的也不迟。</p><br><p>标题为:请问PI算法中的P、I分别怎么样确定？</p><p>内容为:P  比例控制 <br />比例控制是一种最简单的控制方式。其控制器的输出与输入误差信号成比例关系。当仅有比例控制时系统输出存在稳态误差（Steady-state error）。 <br /><br />I  积分控制 <br />在积分控制中，控制器的输出与输入误差信号的积分成正比关系。对一个自动控制系统，如果在进入稳态后存在稳态误差，则称这个控制系统是有稳态误差的或简称有差系统（System with Steady-state Error）。为了消除稳态误差，在控制器中必须引入“积分项”。积分项对误差取决于时间的积分，随着时间的增加，积分项会增大。这样，即便误差很小，积分项也会随着时间的增加而加大，它推动控制器的输出增大使稳态误差进一步减小，直到等于零。因此，比例+积分(PI)控制器，可以使系统在进入稳态后无稳态误差。 <br /><br /><a href="http://zhidao.baidu.com/question/27536137.html?fr=qrl3" target="_blank">http://zhidao.baidu.com/question/27536137.html?fr=qrl3</a></p><br><p>标题为:胸围杯罩的具体算法？</p><p>内容为:　　罩杯尺寸的计算方法如下：<br />　　罩杯尺寸 = 胸围 －下胸围 　　胸罩罩杯尺寸说明表 　<br />　　罩杯型号 胸围与胸下围的差距<br />　　AA 约7.5cm<br />　　A 约10cm<br />　　B 约12.5cm<br />　　C 约15cm<br />　　D 约17.5cm<br />　　E 约20cm<br />　　F 约22.5cm<br />　　G 约25cm<br />　　H  约27.5cm<br />　　I 约30cm<br />　　以此类推 　　胸罩尺寸=下胸围尺寸 　　（例如:胸围是83公分.下胸围是70公分） 应穿着=&gt; 70 B 的胸罩 　　文胸尺码对照表 　<br />　　下胸围 上胸围 上下胸围之差距 杯型  尺码<br />　　70cm  80cm 10cm左右 A 70A<br />　　70cm  82.5cm 12.5cm左右 B  70B<br />　　70cm  85cm 15cm左右 C 70C<br />　　75cm 85cm 10cm左右 A 75A<br />　　75cm  87.5cm 12.5cm左右  B  75B<br />　　75cm  90cm 15cm左右 C 75C<br />　　80cm  90cm 10cm左右 A 80A<br />　　80cm 92.5cm 12.5cm左右 B 80B<br />　　80cm  95cm 15cm左右 C 80C<br />　　85cm  95cm  10cm左右  A 85A<br />　　85cm  97.5cm 12.5cm左右 B 85B<br />　　85cm  100cm 15cm左右 C  85C<br />　　90cm  100cm  10cm左右  A 90A<br />　　90cm 102.5cm  12.5cm左右  B 90B<br />　　90cm  105cm 15cm左右  C 90C<br />　　下胸围尺寸换算： 　　<br />　　有时候会看到罩杯前面32，34，36等这样尺寸字样　而32,34,36,38指的是胸下围的尺寸。 　　<br />　　下胸围 　<br />　　68~73cm=32=70 　<br />　　73~78cm=34=75 　<br />　　78~83cm=36=80 　　<br />　　83~88cm=38=85 　　<br />　　88~93cm=40=90<br />　　希望对你有帮助</p><br></body>
    </html>
    